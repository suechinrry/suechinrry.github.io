[{"content":"创建仓库 使用git init\n会在当前目录下创建一个 .git 子目录，里面包含了 Git 所需的所有文件和数据结构，用于跟踪版本历史。\n此时，你可以开始在这个目录下使用 Git 来管理文件，进行版本控制等操作。\n后面跟名称会在当前目录下新建名称为已给名称的目录\n使用git clone\n补充：\n点击 Code 按钮，你会看到一个 URL 地址框。\nHTTPS URL：如果你使用 HTTPS 协议，复制 https://github.com/用户名/仓库名.git。 SSH URL：如果你使用 SSH 协议，复制 git@github.com:用户名/仓库名.git（前提是你已经配置了 SSH 密钥）。 1 git clone https://github.com/用户名/仓库名.git 本地数据管理 工作区 暂存区 本地仓库 将文件添加到仓库 git status 查看仓库状态 追踪了并且提交到本地仓库的、且未作修改的文件，在执行 git status 时 不会显示。\n这是因为 git status 只会显示以下几种情况：\n修改了的文件（即已经追踪的文件有更改，但尚未提交到仓库）。 新增文件（尚未被 Git 跟踪的新文件）。 已暂存的文件（已用 git add 添加到暂存区，准备提交的文件）。 与远程仓库的差异（如有未推送的提交或与远程分支不同的状态）。 git add 将文件添加到暂存区\n可以使用通配符批量添加\n还可以使用git add . 添加当前文件夹下的所有文件\ngit rm --cached \u0026lt;文件名\u0026gt; 从暂存区移除\ngit ls-files 查看暂存区里的内容\ngit commit 提交暂存区里的文件到本地仓库\n正确的使用方式（包含提交信息） git commit -m \u0026quot;修复登录页面的样式问题\u0026quot; ``-m ，选项用于为提交添加一条提交信息\n提交信息为空，Git 会报错\ngit log 查看提交记录\n后面可以跟选项，展示提交记录\n回退版本 默认为mixed\n补充：提交后，暂存区的内容不会被删除，暂存区依然可以用来存放对文件的新修改，直到再次提交。\ngit reset --XX 提交id（版本id）\ngit reset --soft\n回退到某个版本，但是保留工作区和暂存区的所有内容\ngit reset --hard\n回退到某个版本，但是丢弃工作区和暂存区的所有内容\ngit reset --mixed\n回退到某个版本，但是保留工作区的内容\n查看差异 git diff\n1. 查看工作目录和暂存区之间的差异 git diff 默认情况下，比较工作目录和暂存区的差异，也就是你已经修改但尚未使用 git add 暂存的文件内容：\n1 git diff 它会显示自上次提交以来，工作目录中尚未暂存的更改。\n2. 查看暂存区和上次提交之间的差异 如果你已经通过 git add 将更改暂存，但还没有提交，可以使用以下命令查看暂存区和最后一次提交之间的差异：\n1 git diff --cached 这个命令会显示暂存区的内容和上一次提交的内容之间的差异。\n3. 查看工作目录和上次提交之间的差异 HEAD是分支的最新提交节点\n如果你想查看工作目录和最后一次提交之间的所有差异（包括已经暂存和未暂存的更改），可以使用：\n1 git diff HEAD 这里的 HEAD 表示当前分支的最新提交。\n4. 查看某个文件的差异 你也可以指定某个文件来查看它的差异。例如，要查看 file.txt 的差异，可以使用：\n1 git diff file.txt 这样只会显示 file.txt 文件的更改。\n5. 查看两个分支之间的差异 如果你想查看两个分支之间的差异，可以指定两个分支名。例如，查看 main 和 feature 分支之间的差异：\n1 git diff main..feature 这会显示 feature 分支相对于 main 分支的差异。\n6. 查看两个提交之间的差异 如果你想查看两个特定提交之间的差异，可以使用：\n1 git diff commit1 commit2 其中 commit1 和 commit2 是提交的 SHA-1 哈希值、分支名或者引用（例如 HEAD~1）。\n7. 查看某个文件在两个提交之间的差异 如果你只对某个文件在两个提交之间的差异感兴趣，可以使用：\n1 git diff commit1 commit2 -- file.txt 8. 查看修改的统计信息 如果你只想查看文件修改的统计信息，而不显示具体的修改内容，可以加上 --stat 选项：\n1 git diff --stat 删除文件 git rm 文件名\n--cached 只从 Git 跟踪中移除文件，保留文件在本地磁盘上。 -r 或 --recursive 递归删除目录及其内容。 -f 或 --force 强制删除文件，即使文件是只读的或有未提交的修改。 -n 或 --dry-run 模拟删除操作，显示将被删除的文件，但不实际删除。 删除工作区和暂存区，但是版本库中还存在，所以还要记得提交\n.gitignore文件 生效前提：要忽略的文件不能是已经添加到仓库里的文件\n文件格式 .gitignore 文件的格式非常简单，每行代表一个模式，用来匹配需要忽略的文件或目录。以下是 .gitignore 文件的一些常见规则：\n常见规则和语法 使用标准的Blob模式匹配\n\\*：匹配零个或多个字符。\n例子：*.txt 匹配所有 .txt 文件。\n?：匹配单个字符。\n例子：file?.txt 匹配 file1.txt, fileA.txt 等，但不匹配 file10.txt。\n[]：匹配指定范围内的单个字符。\n例子：file[1-3].txt 匹配 file1.txt, file2.txt, file3.txt。\n\\**（用于递归匹配目录）：\n例子：**/*.txt 匹配所有子目录中的 .txt 文件。\n忽略特定文件或目录\n你可以指定要忽略的文件或目录的路径。例如：\n忽略文件夹必须要带/\n1 2 3 example.txt logs/ build/ 上面表示 example.txt 文件，logs 目录和 build 目录会被 Git 忽略。\n忽略特定扩展名的文件\n使用通配符 * 来忽略所有符合模式的文件。例如：\n1 2 *.log *.tmp 这样会忽略所有 .log 和 .tmp 后缀的文件。\n忽略某个文件夹中的某种类型文件\n如果你只想忽略特定文件夹中的文件，可以指定路径。例如：\n1 logs/*.log 这表示只忽略 logs 文件夹中的 .log 文件。\n忽略目录中的所有文件\n要忽略某个目录中的所有文件，使用 * 通配符。例如：\n1 build/* 这会忽略 build 目录中的所有文件，但 build 目录本身不会被忽略。\n取消对已忽略文件的忽略\n如果 .gitignore 中的某个文件之前被忽略，但你后来希望 Git 追踪它，可以使用 ! 取消忽略：\n1 !important.txt 上面的规则表示取消对 important.txt 文件的忽略，Git 会开始追踪它。\n注释\n你可以在\n1 .gitignore 文件中添加注释，注释以 # 开头。例如：\n1 2 # 忽略所有的 .log 文件 *.log 远程仓库 使用ssh 配置ssh密钥 ","date":"2025-02-27T00:00:00Z","permalink":"https://suechinrry.github.io/p/git/","title":"git"},{"content":"问题和注意点 问题 WebMvcConfigurationSupport 和 WebMvcConfigurer 维度 WebMvcConfigurationSupport WebMvcConfigurer 作用 完全接管 MVC 配置 扩展默认 MVC 配置 自动配置影响 会禁用 Spring Boot 自动配置，需要手动配置静态资源、消息转换等 不会影响自动配置 适用场景 需要完全控制 MVC 逻辑 仅需部分扩展 MVC 配置 配置方式 继承 WebMvcConfigurationSupport 实现 WebMvcConfigurer 静态资源映射 需要手动配置，否则失效 仍然可用 拦截器、跨域等 需要手动配置 直接扩展 @Resource和@Autowired @Resource @Autowired 来源 Java 标准库（javax.annotation.Resource） Spring 框架（org.springframework.beans.factory.annotation.Autowired） 注入方式 默认按名称，若无名称则按类型 默认按类型 是否支持 @Qualifier 可以搭配 @Qualifier 使用 可以搭配 @Qualifier 使用 是否支持 required=false 不支持 支持 是否与 Spring 强绑定 不是，JSR-250 规范的一部分，可用于其他框架 是，属于 Spring 组件 解决ObjectMapper不能直接序列化 解决ObjectMapper不能直接序列化 java.time.LocalDateTime\n因为 Jackson 默认不支持 Java 8 的时间类型。\n添加**jackson-datatype-jsr310 依赖**\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.datatype\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-datatype-jsr310\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 可以创建一个 @Bean 来配置 ObjectMapper：\n1 2 3 4 5 6 7 8 9 10 @Configuration public class JacksonConfig { @Bean public ObjectMapper objectMapper() { ObjectMapper objectMapper = new ObjectMapper(); objectMapper.registerModule(new JavaTimeModule()); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); return objectMapper; } } 或者，在 application.yml 配置：\n1 2 3 4 spring: jackson: serialization: write-dates-as-timestamps: false new TypeReference\u0026lt;List\u0026lt; ShopType\u0026raquo;()不能直接填List\u0026lt; ShopType\u0026gt;吗\n1 2 3 List\u0026lt;ShopType\u0026gt; typeList; ...... typeList =objectMapper.readValue(listJson,new TypeReference\u0026lt;List\u0026lt;ShopType\u0026gt;\u0026gt;(){}); 不能直接填 List\u0026lt; ShopType \u0026gt;.class，因为 Java 的泛型会在运行时被擦除（Type Erasure），导致 ObjectMapper 无法正确推断 List\u0026lt; ShopType \u0026gt; 的具体类型。\n为什么不能使用 List\u0026lt; ShopType \u0026gt;.class？\n在 Java 运行时，List\u0026lt; ShopType \u0026gt;.class 实际上被擦除成 List.class，ObjectMapper 只知道它是一个 List，但不知道里面的元素类型。因此，它无法正确地将 JSON 反序列化为 List\u0026lt; ShopType \u0026gt;。\n为什么 new TypeReference\u0026lt;List\u0026lt; ShopType \u0026raquo;() {} 可行？\nTypeReference\u0026lt; T \u0026gt; 通过 匿名子类 的方式 保留了泛型类型信息，使得 ObjectMapper 可以正确解析 List\u0026lt; ShopType \u0026gt;。\n继承handlerInterceptor接口自定义拦截器 自定义拦截器一般不需要使用@Component注解，需要在config类中手动注册拦截器。而且，Spring 的 @Autowired 依赖注入（DI）仅对 Spring 管理的 Bean 生效，而如果拦截器没有被 Spring 扫描（即没有使用 @Component、@Service、@Controller 等注解），Spring 就不会管理它，也就不能对其中的字段进行自动注入。 在自定义拦截器类里无法注入某对象，可以在config类中用形参的形式传入 运行sql文件 在navicat里运行没有建库语句的sql文件，要先新建一个数据库，在右键运行sql文件\n@Slf4j 是什么？ @Slf4j 是 Lombok 提供的一个注解，它会自动帮你生成 log 变量，并使用 SLF4J 作为日志门面。\n等效于手动定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import org.slf4j.Logger; import org.slf4j.LoggerFactory; @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements IUserService { // Lombok 的 @Slf4j 注解会自动生成这个 log 变量 private static final Logger log = LoggerFactory.getLogger(UserServiceImpl.class); @Override public Result sendCode(String phone, HttpSession session) { log.info(\u0026#34;code:{}\u0026#34;, code); return Result.ok(); } } 所以，@Slf4j 的本质就是帮你省去了 private static final Logger log = LoggerFactory.getLogger(XXX.class); 这行代码。\n@SpringBootApplication主要作用 标记为 Spring Boot 启动类。 启用自动配置（@EnableAutoConfiguration）。 启用组件扫描（@ComponentScan）。 允许在类中定义 Bean（@SpringBootConfiguration）。 ${}和#{}的区别 ${}直接拼接字符串\n#{}会先进行预编译，防止sql注入\n例如\n1 2 3 \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;com.sky.entity.User\u0026#34;\u0026gt; SELECT * FROM user WHERE username = #{username} \u0026lt;/select\u0026gt; 会变成\n1 SELECT * FROM user WHERE username = ? ","date":"2025-02-12T00:00:00Z","permalink":"https://suechinrry.github.io/p/problems/","title":"Problems"},{"content":"Linux 安装Linux 安装虚拟机 下载：\nhttps://softwareupdate.vmware.com/cds/vmw-desktop/ws/17.6.2/24409262/windows/core/VMware-workstation-17.6.2-24409262.exe.tar\n检查虚拟网卡：\nwin+r 输入 ncpa.cpl，检查有无虚拟网卡VMnet1和VMnet8\n安装Linux centOS7下载：Index of /7.6.1810/isos/x86_64\n新建虚拟机，选择典型 选择文件 设置名称、密码 放到D盘 更改最大磁盘大小为40GB 启动 快照 打开快照管理器 选择一个快照进行跳转 远程连接Linux 通过第三方软件：FinalShell\n下载网址 FinalShell官网\n连接操作 打开vm虚拟机 打开终端，输入ifconfig，获取ip 用finalshell进行连接 建立连接，双击启动 Linux相关 linux的目录结构 /为根路径。 例如： /user/test/hello.txt\n命令和命令行 命令：一个命令就是一个linux程序，没有图形化界面，可以在命令行提供字符化反馈\n命令行：linux终端，是一种命令提示符页面\n命令格式 在 Linux 中，命令的一般格式如下：\n1 command [options] [arguments] command：要执行的命令，比如 ls、cd、cp 等。 options（可选项）：修改命令行为的选项，通常以一个或两个连字符（- 或 --）开头。例如：-l、--help。 arguments（参数，可选项）：命令操作的对象，通常是文件名、目录名或者其他需要命令处理的内容 Home目录和工作目录 Home目录：每个用户通常都会在 /home 目录下有一个以用户名命名的子目录，作为该用户的主目录。 例如：==/home/用户名==\n工作目录：命令行在执行命令时，需要一个工作目录，默认设置工作目录在该用户的home目录\n特殊路径符 . 表示当前目录，例如：cd ./desktop等同于 cd desktop .. 表示上级目录，例如：cd ..就是返回上一级，cd ../..就是返回上两级 ~ 表示home目录，例如：cd ~等同于cd 命令 ls命令 1 ls [-a -l -h] [linux路径] 作用：列出当前目录的内容，默认为home目录\n-a：-all，列出全部文件夹，包括隐藏的文件/文件夹（==文件或文件夹以 . 开头就能自动隐藏==）\n-l：以列表（竖向）展示内容，并且展示更多的信息。包含==权限信息，所属用户，所属用户组==\n-h：可读格式显示文件大小\n==混合使用==：\n例如：同时使用-a和-l\n写法一：-a -l 写法二：-al，-la 目录切换相关命令 cd 1 cd [linux路径] 带参数：切换到指定目录 不带参数：切换到home目录 pwd 1 pwd 查看当前工作目录\n创建目录命令 mkdir创建目录 只有在home目录下才有创建目录的权限\n1 mkdir [-p] [linux路径] 创建新的目录\n不带选项：创建目录时要求父目录必须存在。如果父目录不存在，则会报错。 -p：用于创建多级目录，如果某个中间目录不存在，-p 会自动创建它们，而不会报错。例如： 1 mkdir -p /home/用户名/project/src 如果 /home/user/project/ 和 /home/user/project/src 目录不存在，mkdir -p 会依次创建它们。如果目录已经存在，它也不会报错。\nmkdir 只会创建目录，不会切换到新目录。 在ls -l命令下的==以d开头的是文件夹，以-开头的是文件==。\n文件操作命令 touch新建文件 1 touch [linux路径] 例如：touch test.txt\n查看文件内容 cat 1 cat [linux路径] 例如：cat test.txt\n==直接显示全部内容==\nmore 1 more [linux路径] 例如：more test.txt\n==可以翻页查看文件，空格是翻到下一页，q是退出查看==\ncp复制文件或文件夹 1 cp [-r] 参数1 参数2 -r：复制文件夹时需要添加-r 参数1：是被复制的文件（文件夹） 参数2：是要复制到的地方 mv移动文件或文件夹 1 mv 参数1 参数2 参数1：是被移动的文件（文件夹） 参数2：是要移动到的地方 mv也可以用来重命名文件，例如：mv test1.txt test2.txt，将test1重命名为test2 rm删除文件或文件夹 1 rm [-r -f] 参数1 参数2 ... ... 参数n -r：和cp一样，-r用于操作文件夹 -f：强制删除，强制删除不会有提示。普通用户删除内容不会有提示，root用户删除内容时才有提示。（普通用户一般用不到-f）。 参数1 参数2 \u0026hellip; \u0026hellip; 参数n，参数代表要删除的文件或路径，用空格隔开。 通配符 *\nabc* 表示以abc开头\n*abc * 表示含有abc的\n*abc 表示以abc结尾的\nwhich查找命令所在位置 1 which 要查找的命令 例如：which cd，which cp等\nfind查找文件所在位置 按文件名查找\n1 find 起始路径 -name 文件名 有空格或特殊字符时，打引号，“文件名” 例如，在/路径下查找文件名为aaa的所在位置， find / -name “aaa”\n按文件大小查找\n1 find 起始路径 -size +(或-)n[kMG] +：表示大于 -：表示小于 n：数字n表示文件大小 kMG：k为KB，M为MB，G为GB 例如，要查找大于500KB的文件，find ~ -size +500k\ngrep筛选文件中特定的行 1 grep [-n] 关键字 文件路径 建议关键字打引号，==有空格或特殊字符时==，“关键字” -n：显示匹配模式的行号。 文件路径：==可作为内容输入端口== wc统计文件内容 1 wc [-l -w -c -m] 文件路径 -l：显示行数。 -w：显示单词数。 -c：显示字节数（通常是文件的大小。 -m：显示字符数（与字节数略有不同，主要是对多字节字符集（如 UTF-8）的处理。 不使用任何选项，wc 命令会默认输出 行数、单词数和字节数 三项统计信息。 tail查看文件尾部的内容 1 tail [-f -数字] linux路径 -f：表示持续监视文件的变化，并显示新增的内容。 -数字：不写默认查看后10行。写了，例如，-5即为查看后5行。 切换root用户 su - root ，密码和普通用户的一样 输入exit退出root echo让命令行输出指定内容 1 echo 想要命令行输出的内容 有空格或特殊字符时，建议打引号。\n管道符 | 将左边命令的结果作为右边命令的输入。\n类似于，左边命令的输出（标准输出）会作为==数据源==传递给右边命令的输入（标准输入）\n反引号`` 被包围的内容，会==被当作命令执行==\n重定向符 输出重定向\u0026gt;：将左边命令的结果覆写到符号右边的文件中 追加重定向\u0026gt;\u0026gt;：将左边命令的结果追加写到符号右边的文件中 vim编辑器 vim是vi的加强版本，vim是文本编辑器\n工作模式\n命令模式，输入模式，底线命令模式。\n命令模式\n进入命令模式\n1 vim 文件路径 文件存在，则用于编辑已有文件；若不存在，则编辑新文件。\n进入输入模式\n按 i、a、o 等键进入输入模式，不同字母光标位置不同，进行编辑。\n按 i：在光标当前位置进入输入模式。\n按 I：在当前行的第一个非空字符前进入输入模式。\n按 a：在光标当前位置后进入输入模式（即光标后一个字符开始输入）。\n按 A：在当前行的末尾进入输入模式。\n按 o：在当前行下面新建一行并进入输入模式。\n按 O：在当前行上面新建一行并进入输入模式。\n快捷键操作\n进入底线命令模式\n按 : 键进入底线命令模式\n输入模式\n按esc退出，进入命令模式\n底线命令\n按wq，保存并退出vim\n按q！，强制退出\n用户和权限 普通用户在home目录下，权限不受限。出了home目录只有只读和执行的权限，无修改权限。\nsu切换用户 1 su [-] [用户名] -：带-表示切换用户后加载环境变量。 退出通过exit 普通用户切换到其他用户需要密码，root用户不用 不写用户名，即su -，会切换到root用户 sudo授权 给普通命令授权，临时以root用户身份执行。\n1 sudo 命令 前提：获得sudo认证\n使用root用户，使用visudo命令\n在文件的最后一行添加\n1 用户名 ALL=(ALL)\tNOPASSWD:ALL :wq保存并退出\n用户和用户组 用户组管理 创建用户组\n1 groupadd 用户组名 删除用户组\n1 groupdel 用户组名 用户管理 创建用户\n1 useradd [-g -d] 用户名 -g：-g 用户组名，将用户添加到已存在的用户组中。不带-g，会自动创建同名的用户组并加入 -d：-d home目录，可以自定义home目录。不带则默认为/home/用户名 删除用户\n1 userdel [-r] 用户名 -r：带了就连同home目录一起删除，不带则只删除用户不删除home目录 查看用户所属组\n1 id 用户名 不带用户名则查看自身\n修改用户所属组\n1 usermod -aG 用户组 用户 查询所有用户\n1 getent passwd 查询所有用户组\n1 getent group 权限信息 ls -l展示出的信息中\n![](屏幕截图 2025-01-20 215232.png)\n其中r为读权限，w为写权限，x为执行权限\nchmod修改权限信息 1 chmod [-R] 权限 文件或文件夹 -R：对文件夹的全部内容应用同样操作\n例如：chmod u=rwx,g=rx,o=x test.txt\n其中u为所属用户的权限，g为所属用户组的权限，o为其他用户的权限\n简化写法：\n类似于rwx最小项。- - x表示001，即为1。\n上面示例可简化为：chmod 751 test.txt\nchown改变所属 只适用于root用户\n1 chown [-R] [用户][:用户组] 文件或文件夹 -R：对文件夹的全部内容应用同样操作 快捷键 ctrl+c 强制停止\nctrl+d 退出\n不能用于退出vi或者vim\nhistory 查看历史命令\n!内容自动匹配并执行历史记录中最近的一条\nctrl+r 输入内容去匹配历史命令。回车后可直接执行这条历史命令；按左or右键得到该命令\nctrl+l 清屏，等同于clear命令\n软件安装 yum命令安装软件 使用报错\n先检查是不是网络连接的问题\n若不是，则（以下操作均需要root权限）\n下载阿里云的镜像源配置文件\n1 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 清理旧缓存\n1 yum makecache PackageKit 服务占用了 Yum 的锁\n暂停并终止 PackageKit 服务\n1 systemctl stop packagekit 禁用 PackageKit 服务\n1 systemctl disable packagekit rpm是linux的安装包格式\n1 yum [-y] [install | remove | search] 软件名称 -y：自动安装，无需手动确认安装或卸载 yum命令==需要root权限或sudo提权== systemctl命令控制软件的关闭和启动 1 systemctl [start | stop | restart | reload | status | enable | disable] 服务名称 start：启动某个服务。\nstop：停止某个服务。\nrestart：重启某个服务。\nreload：重新加载某个服务的配置，不重启服务。\nstatus：查看某个服务的当前状态。\nenable：设置服务开机启动。\ndisable：禁用服务的开机启动。\nsystemctl 不仅可以控制系统内置的服务，还可以控制一些第三方软件和服务，只要这些软件或服务已经通过 systemd 配置为服务单位（unit）。没有注册可以通过手动注册来实现控制\nln命令创建软连接 **软连接：**将文件或文件夹链接到其他位置，==类似于windows的快捷方式==\n1 ln -s 参数1 参数2 参数1：要链接的文件或文件夹 参数1：要链接去的地方 日期和时区 date命令查看时间 好的！按照类似的格式，date 命令的说明如下：\ndate 命令用法 date 命令用于显示和设置系统的日期和时间。\n1 date [-d] [+格式化字符串] -d：显示指定日期的时间，可以用于计算日期（如计算未来或过去的日期）。 ntp命令进行时间同步和校准 安装ntpyum -y install ntp 设置开机自启动systemctl enable ntpd 手动校准，需要root权限ntpdate -u ntp.aliyun.com ip地址和主机名 查询ip 1 ifconfig 主机名 查看主机名 1 hostname 修改主机名\n1 hostnamectl set-hostname 新主机名 域名解析 先查看本机记录。/etc/hosts 在联网去DNS服务器 虚拟机配置固定ip 虚拟机中配置ip地址的网关和网段（ip地址的范围）\n![](屏幕截图 2025-01-24 165409.png)\n![](屏幕截图 2025-01-24 165812.png)\n![](屏幕截图 2025-01-24 165945.png)\n手动修改配置文件，固定ip\n网卡配置文件/etc/sysconfig/network-scripts/ifcfg-ens33\n使用vim对其进行编辑\n修改第四行\ndhcp是自动获取ip，将dhcp换为static\n新增四行内容\n网络传输 ping检查指定的网络服务器是否为可联通状态 1 ping [-c num] ip或主机名 -c num：检查的次数，不写则无限次数持续检查 wget非交互式文件下载器 1 wget [-b] url -b:后台下载，将日志写到工作目录下的wget-log文件下 url：下载链接 curl命令用于发送http网络请求 用于下载文件、获取信息\n1 curl [-O] url -O：用于下载文件，当url是下载链接时保存文件 url：要发起请求的网络地址 端口 通过端口可以锁定计算机的具体程序\nLinux 系统中，端口是标识网络服务的通信通道，共有 65535 个端口号可供使用\n0 - 1023：知名端口（Well-known Ports），由 IANA（Internet Assigned Numbers Authority）分配，用于重要的服务和应用，例如 HTTP（80）、HTTPS（443）、SSH（22）、FTP（21）等。\n1024 - 49151：注册端口（Registered Ports），这些端口号是为某些应用程序、服务和进程保留的，但不如知名端口那样严格，通常由开发者或组织申请使用。通常可以随意使用\n49152 - 65535：动态端口（Dynamic or Private Ports），这些端口通常用于客户端的临时端口，如在建立连接时操作系统会自动分配这些端口。\nnmap命令查看端口占用 先下载nmap\n查看占用情况\n1 nmap 要查看的ip地址 netstat命令查看指定端口的占用情况 需要先下载\n1 yum -y install net-tools 使用\n1 netstat -anp | grep 端口号 格式正确的情况下没返回说明端口没有被使用：指定的端口号当前没有进程在监听。\n进程管理 为管理运行的程序，每个运行的程序都会被操作系统注册为系统中的一个进程。并为每个进程分配一个独有的进程id。\nps命令查看进程信息 1 ps [-e -f] -e：展示全部进程 -f：以完全格式化的形式展示信息（展示全部信息） 一般合起来用ps -ef 可以通过管道符|和grep来进行过滤，例如查找tail命令ps -ef | grep tail\nkill关闭进程 1 kill [-9] 进程id -9：强制关闭 监控主机状态 top查看资源占用 类似与windows任务管理器，默认每隔5秒刷新一次\n1 top ![](屏幕截图 2025-01-25 141245.png)\n基本选项\n-d \u0026lt;时间间隔\u0026gt;：设置刷新间隔（单位为秒）。默认值通常为 3 秒，例如 top -d 2 表示每 2 秒刷新一次。 -n \u0026lt;次数\u0026gt;：指定刷新次数后退出。例如，top -n 5 表示刷新 5 次后退出。 -b：以批处理模式运行，输出结果适合重定向到文件。例如，top -b -n 1 \u0026gt; output.txt 将当前信息保存到 output.txt。 -p \u0026lt;PID\u0026gt;：仅显示指定 PID 的进程信息。例如，top -p 1234 只监控进程号为 1234 的进程。 -u \u0026lt;用户名\u0026gt;：仅显示指定用户的进程。例如，top -u root。 -U \u0026lt;用户ID\u0026gt;：与 -u 类似，但通过用户 ID 过滤。 -H：显示线程级别的信息。 -o \u0026lt;字段\u0026gt;：按指定字段排序。例如，top -o %CPU 按 CPU 使用率排序。 运行时交互键\n当运行 top 后，可以通过以下键盘操作动态调整显示内容：\n排序相关 P：按 CPU 使用率排序（默认）。 M：按内存使用量排序。 T：按进程运行时间排序。 筛选相关 u：筛选特定用户的进程。 k：终止指定 PID 的进程。 显示相关 z：切换颜色显示。 x：高亮排序列。 c：切换显示完整命令行或仅显示进程名称。 f：调整显示字段。 h：显示帮助信息。 q：退出 top。 df命令查看硬盘的使用情况 1 df [-h] -h：单位显示 iostat命令查看cpu和磁盘信息 1 iostat [-x] [参数1] [参数2] -x：显示更多信息 参数1：数字，表示刷新间隔（秒） 参数2：数字，表示刷新几次，不写则一直刷新 sar查看网络的相关统计 由于十分复杂\n常用的写法\n1 sar -n DEV num1 num2 -n：查看网络 DEV：查看网络接口 num1：数字，表示刷新间隔（秒） num2：数字，表示刷新几次，不写则一直刷新 环境变量 环境变量是一种在操作系统中用于存储配置信息的键值对，方便系统和应用程序获取公共参数。它们像全局变量一样，可以影响系统或程序的运行环境。\nenv命令查看当前系统的环境变量 1 env $符号 通过$用环境变量的key去获取值\n例如，\n1 echo $PATH 临时\n1 export 变量名=变量值 永久\n针对当前用户：在~/bashrc文件中 针对所有用户：在/etc/profile文件中 在配置文件里写入export 变量名=变量值 立即生效使用source 配置文件名称 上传和下载 可以鼠标推拽 通过命令 安装lrzsz rz上传，window上传过来 sz下载 压缩和解压 tar和gzip更为常用\n.tar\n定义： .tar 是一种打包格式，用于将多个文件和目录合并成一个文件，方便归档和传输。 特点 仅打包文件和目录，不会压缩数据。 文件大小保持不变。 通常用于备份和归档。 .gz\n定义： .gz 是一种压缩格式，基于 Gzip（GNU zip）压缩算法，用于减少文件大小。 特点 只能压缩单个文件。 不具备打包功能。 常用于网络传输或磁盘存储优化。 .tar.gz\n定义： .tar.gz 是 .tar 和 .gz 的组合，先将文件和目录打包成 .tar 文件，再对 .tar 文件进行 Gzip 压缩。 特点 兼具打包和压缩功能。 是 Linux 系统中最常见的压缩包格式。 tar命令压缩或解压tar和gzip文件 1 tar [-z -c -x -C -v -f] 参数1 参数2 ... ... 参数n -z：不管是解压还是压缩，都使用gzip算法。不写则使用tarball算法，要使用的话一般放在第一个 -c：创建压缩文件，用于压缩模式 -x：解压模式 -C：用于解压模式，选择解压目的地 -v：查看进度。用于显示压缩、解压过程 -f：指定打包或解压的文件名（如 archive.tar）。必须放在所有选项的最后一个 常用组合 压缩 -cvf 将若干文件压缩到某个.tar文件\n例如，将1.txt和2.txt压缩到test.tar中\n1 tar -cvf test.tar 1.txt 2.txt 该命令会将当前目录下的 1.txt 和 2.txt 文件打包到一个名为 test.tar 的归档文件中。\n打包完成后，1.txt 和 2.txt 原文件依然保留，它们的副本被存储在 test.tar 中。\n-zcvf\n先将 1.txt 和 2.txt 文件打包为一个 test.tar 文件，然后用 gzip 压缩生成最终的 test.tar.gz 文件。\n1 tar -zcvf test.tar 1.txt 2.txt 解压 -xvf 解压到当前目录。\n1 tar -xvf test.tar -xvf 解压到指定目录。\n1 tar -xvf test.tar -C /home/jieya -zxvf 解压到指定目录。\n1 tar -zxvf test.tar.gz -C /home/jieya zip、unzip命令压缩或解压zip文件 zip命令压缩文件 1 zip [-r] 参数1 参数2 ... ... 参数n -r：压缩内容含有文件夹要使用-r\n例如，将a.txt和b.txt压缩到test.zip里\n1 zip -r test.zip a.txt b.txt unzip解压 1 unzip [-d] zip压缩包文件 -d：同上面tar命令的-C类似，指定解压目录\n解压到当前目录\n例如，unzip test.zip\n解压到指定目录\n例如，unzip test.zip -d /home/jieya\n目录不存在，unzip 会报错，提示目标目录不存在。有同名文件会覆盖\n","date":"2025-01-15T00:00:00Z","permalink":"https://suechinrry.github.io/p/linux/","title":"Linux"},{"content":"Linux的相关知识 Redis简介 Redis 是一个基于键值对（Key-Value）的 NoSQL 数据库，属于非关系型数据库。\n官网：\n中文：https://www.redis.com.cn/documentation.html\n英文：Redis - The Real-time Data Platform\n参考命令：http://doc.redisfans.com/\n下载 下载文件 redis/redis-hashes: Redis tarball SHA1 hashes\n下载依赖 1 yum -y install gcc tcl 上传文件 需要root用户，是finalshell用root用户连接\n并放到/usr/local/src\n解压文件 1 tar -zxvf redis-7.4.2.tar.gz 进入目录 1 cd redis-7.4.2 运行编译命令 1 make \u0026amp;\u0026amp; make install 安装完成后，默认安装在/usr/local/bin下\n启动 直接启动redis-server 指定配置启动 安装目录下的配置文件 /usr/local/src/redis-7.4.2的redis.conf\n先备份cp redis.conf redis.conf.bck\n修改\nbind 127.0.0.1改为bind 0.0.0.0 daemonize yes requirepass 改为 require * * * * 开机自启动 我们也可以通过配置来实现开机自启。\n首先，新建一个系统服务文件：\n1 vi /etc/systemd/system/redis.service 内容如下：\n1 2 3 4 5 6 7 8 9 10 11 [Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-7.4.2/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target 然后重载系统服务：\n1 systemctl daemon-reload 现在，我们可以用下面这组命令来操作redis了：\n1 2 3 4 5 6 7 8 # 启动 systemctl start redis # 停止 systemctl stop redis # 重启 systemctl restart redis # 查看状态 systemctl status redis 执行下面的命令，可以让redis开机自启：\n1 systemctl enable redis redis命令行客户端 redis-cli\n1 redis-cli [option] [commands] 常见option\n-h 127.0.0.1 要连接redis的ip，默认是127.0.0.1 -p 6379 要连接redis的端口，默认是6379 -a 密码 指定redis的访问密码 其中的commonds就是Redis的操作命令，例如：\nping：与redis服务端做心跳测试，服务端正常会返回pong\n![](屏幕截图 2025-01-27 114601.png)\n图形化界面 Redis的图形化桌面客户端，地址：https://github.com/uglide/RedisDesktopManager\n不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。\n在下面这个仓库可以找到安装包：https://github.com/lework/RedisDesktopManager-Windows/releases\n建立连接 连接前要关闭centos防火墙systemctl stop firewalld 常用命令 命令参考\n数据结构 字符串（String） 基本特性：Redis 的字符串类型是二进制安全的，可以存储任何类型的数据，比如 JPG 图片或者序列化后的对象。 操作 SET key value：设置键值对。 GET key：获取键的值。 INCR key：将键的值增加 1。 DECR key：将键的值减少 1。 APPEND key value：在已有值的基础上追加数据。 哈希（Hash） 基本特性：哈希是键值对集合，适用于存储对象类型的数据，比如用户信息（字段：姓名、年龄、性别等）。 操作 HSET key field value：设置哈希表中的字段值。 HGET key field：获取哈希表中字段的值。 HGETALL key：获取哈希表中所有字段和值。 HMSET key field1 value1 field2 value2：设置多个字段的值。 HDEL key field：删除哈希表中的字段。 列表（List） 基本特性：列表是一个按顺序排列的字符串集合，支持从两端进行推入（push）和弹出（pop）。适合做消息队列等应用。 操作 LPUSH key value：将元素插入列表头部。 RPUSH key value：将元素插入列表尾部。 LPOP key：从列表头部弹出元素。 RPOP key：从列表尾部弹出元素。 LRANGE key start stop：返回列表中指定范围的元素。 集合（Set） 基本特性：集合是无序的字符串集合，不允许重复元素，适合用于去重等场景。 操作 SADD key member：将元素添加到集合中。 SREM key member：从集合中移除元素。 SMEMBERS key：获取集合中所有的元素。 SISMEMBER key member：检查元素是否存在于集合中。 SUNION key1 key2：返回两个集合的并集。 有序集合（Sorted Set，Zset） 基本特性：有序集合是一个包含分数（score）的字符串集合，每个元素都会关联一个分数，集合中的元素根据分数排序。 操作 ZADD key score member：添加元素及其分数。 ZRANGE key start stop：返回指定范围的元素（按分数排序）。 ZREM key member：移除元素。 ZINCRBY key increment member：给指定元素增加分数。 ZREVRANGE key start stop：返回指定范围的元素（按分数降序排序）。 位图（Bitmap） 基本特性：位图是一个特殊的字符串，可以在其中操作位（bit），适合做大规模的计数、状态标记等。 操作 SETBIT key offset value：设置指定位置的位值。 GETBIT key offset：获取指定位置的位值。 BITCOUNT key：统计键中为 1 的位的数量。 HyperLogLog 基本特性：HyperLogLog 是一种基数估计数据结构，适用于统计唯一元素的数量，能够在极低的内存消耗下提供近似值。 操作 PFADD key element：添加元素到 HyperLogLog。 PFCOUNT key：返回 HyperLogLog 中元素的基数估计值。 地理空间（Geospatial） 基本特性：Redis 提供了对地理空间的支持，可以存储和查询地理位置数据（经纬度）。 操作 GEOADD key longitude latitude member：添加地理坐标。 GEODIST key member1 member2：计算两个位置之间的距离。 GEORADIUS key longitude latitude radius：根据半径获取周围的地理位置。 流（Streams） 基本特性：流是一个用于处理数据流的结构，可以用于消息队列、事件记录等场景。 操作 XADD key * field value：向流中添加一条新消息。 XRANGE key start end：读取流中的消息。 XREAD key count block：阻塞式读取流中的消息。 发布/订阅（Pub/Sub） 基本特性：Redis 支持发布/订阅模式，允许客户端订阅某个频道，然后接收该频道发布的消息。 操作 PUBLISH channel message：向频道发布消息。 SUBSCRIBE channel：订阅频道。 UNSUBSCRIBE channel：取消订阅。 通用命令 key的层级结构：用冒号分隔\n例如：学校:班级:姓名\nKEYS\n查看所有符合模板的key\n通配符\nh?llo matches hello, hallo and hxllo\nh*llo matches hllo and heeeello\nh[ae]llo matches hello and hallo, but not hillo\nh[^e]llo matches hallo, hbllo, \u0026hellip; but not hello\nh[a-b]llo matches hallo and hbllo\n*？表示1个，表示多个，[ab]是a或者b，[a-b]是a到b，[ ^b ]是除了b\nDEL\n删除key\n1 DEL key1 (key2 key3 ... ...) EXISTS\n判断是否存在key\n1 EXISTS key EXPIRE\n设置key有效期\n1 EXPIRE key time（单位是s） TTL\n查看key有效期\n-1为永久有效\nString类型 类型，最大空间不超过512m 整数int 浮点float 普通字符串 常用命令 SET添加或修改\nSET key value\nGET\nMSET批量添加\nMSET k1 v1 k2 v2\nMGET批量获取\nINCR整数型自增1\nINCR key\n返回加1后的值\nINCRBY指定增长的数值，可为负数\nINCRBY key num\nINCRBYFLOAT\n浮点型自增，并指定增长的数值\nSETNX\n添加一个string类型，要key不存在， 存在则不执行\nSETNX key value等同于SET key value nx\nSETEX\nSETEX key num value在添加键值对时就设定有效期（num秒）\nHash类型 结构 一个 Hash 是由多个 字段（field） 和对应的 值（value） 组成的。每个字段和值都可以是字符串类型。\n与普通的字符串类型相比，Hash 类型的优势在于可以将多个值存储在同一个键下。\n常用命令 HSET key field1 value2 （field2 value2 … …） 添加和修改多个field的值 HGET key field 获取一个Hash类型的key的field的value HMGET key field1 field2 … … 获取key的多个field的值 HGETALL key 获取key的所有field和value HKEYS key 获取key的所有field HVALS key 获取key的所有value HINCRBY key field increment hash类型的key的整数型field指定增加量increment HINCRBYFLOAT key field increment Hash 类型中的字段执行浮点数的增减。 HSETNX key field value 添加一个Hash类型的key的field，前提是field不存在 List类型 List 类型 是一个双向链表，支持 正向检索 和 反向检索，即可以从头到尾（正向）或从尾到头（反向）访问、添加和删除数据。\n正向检索 是从左到右（插入顺序），通过正索引（如 0, 1, 2）访问。 反向检索 是从右到左（逆序），通过负索引（如 -1, -2, -3）访问。 特点 有序 元素可重复 插入删除快 查询速度一般 常用命令 LPUSH key value1 value2 … … 向list类型的key的左侧插入一个或多个元素\nLPOP key 移除并返回左侧第一个元素，没有则返回nil\nLPOP key [count] 要从左侧弹出的元素个数\nRPUSH key value1 value2 … … 向list类型的key的右侧插入一个或多个元素\nRPOP key 移除并返回右侧第一个元素，没有则返回nil\nLRANGE key start stop 返回列表中指定范围的元素。(下标从0开始)\nBLPOP和BRPOP 功能和 LPOP、RPOP 类似，但增加了阻塞功能，\n​ 不会直接返回nil,\n​ BLPOP key [key ...] timeout，其中timeout单位为秒\nSet类型 Set 类型是无序的、唯一的集合，可以存储多个不重复的元素\n特点 唯一性：集合中的元素是唯一的，不能重复。 无序性：集合中的元素是无序的，不能通过索引访问。 操作高效：添加、删除、判断是否存在的时间复杂度都是 O(1)O(1)O(1)。 支持集合运算：提供交集、并集、差集等操作。 常用命令 SADD key member [member \u0026hellip;] 向集合 key 中添加一个或多个成员。如果成员已存在，则忽略。 SREM key member [member \u0026hellip;] 移除集合 key 中的一个或多个成员。如果成员不存在，则忽略。 SISMEMBER key member 判断成员 member 是否是集合 key 的成员。如果是，返回 1，否则返回 0。 SMEMBERS key 获取集合 key 中的所有成员。 SCARD key 获取集合 key 中的成员数量。 对多个集合\nSINTER key [key \u0026hellip;] 返回一个或多个集合的交集。 SUNION key [key \u0026hellip;] 返回一个或多个集合的并集。 SDIFF key [key \u0026hellip;] 返回一个集合与其他集合的差集。 ​ 例如：SDIFF set1 set2 set3这个命令的意思是：返回 set1 中有，但 set2 和 set3 中都没有的元素。\nSortedSet类型 Sorted Set（有序集合） 是一种带有权重（分数）的集合，它类似于普通的 Set，但每个元素都有一个score（分数），并且集合中的元素按照分数从小到大排序。\n特点 可排序 元素不重复 查询速度快 常用命令 ![](屏幕截图 2025-01-31 213148.png)\njava客户端 链接：Connect with Redis client API libraries | Docs\njedis 链接：Jedis guide (Java) | Docs\n引入依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;redis.clients\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jedis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 建立连接\n1 2 3 jedis = new Jedis(\u0026#34;ip\u0026#34;, 6379); // 连接到 Redis jedis.auth(\u0026#34;password\u0026#34;); // 密码 jedis.select(0);//选择库，选择data0 和junit依赖相关：\n@BeforeEach 和 @AfterEach 是 JUnit 5 中的注解，用于在每个测试方法执行之前和之后执行一些初始化和清理的操作。\n@BeforeEach：这个注解标记的方法会在每个测试方法执行之前运行。通常用于执行一些初始化操作，比如创建对象、初始化变量等。 @AfterEach：这个注解标记的方法会在每个测试方法执行之后运行。通常用于清理操作，比如关闭连接、释放资源等。 使用\n使用前要关闭linux的防火墙\n关闭\n1 jedis.close(); jedis连接池 jedis直连是线程不安全的，而且频繁地创建和销毁有性能损耗，所以使用Jedi是连接池\n1 2 3 4 5 6 7 8 //配置连接池 JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxIdle(8); // 设置连接池中最大空闲连接数，避免过多空闲连接占用资源 jedisPoolConfig.setMaxTotal(8); // 设置连接池的最大连接数，限制客户端同时可用的 Jedis 连接数量 jedisPoolConfig.setMinIdle(0); // 设置连接池的最小空闲连接数，避免没有空闲连接可用 jedisPoolConfig.setMaxWait(Duration.ofMillis(1000)); // 设置最大等待时间为 1000 毫秒 //创建连接池对象(JedisPoolConfig对象，ip，端口，超时时间，密码) jedisPool = new JedisPool(jedisPoolConfig, \u0026#34;ip地址\u0026#34;, 6379,1000,\u0026#34;密码\u0026#34;); 1 jedisPool.getResource(); // 从连接池中获取一个 Jedis 实例 SpringDataRedis 官网：Spring Data Redis\n依赖 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- redis依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--连接池依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-pool2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 spring: data: redis: host: IP地址 port: 端口 password: 密码 lettuce: pool: max-active: 8 max-idle: 8 min-idle: 0 max-wait: 100 #连接等待时间 自动配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.wh.springdataredis.springdatajedis; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.RedisTemplate; @SpringBootTest class SpringDataJedisApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void testJedis(){ redisTemplate.opsForValue().set(\u0026#34;Class\u0026#34;,\u0026#34;1班\u0026#34;); String aClass =(String) redisTemplate.opsForValue().get(\u0026#34;Class\u0026#34;); System.out.println(aClass); } } 序列化方式 RedisTemplate可以接收任意Object对象作为值存入redis，会将object对象序列化为字节形式，默认jdk序列化。\n缺点：可读性差，占内存\n![](屏幕截图 2025-02-05 191858.png)\n自定义序列化方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Configuration public class RedisConfig { @Bean public RedisTemplate\u0026lt;String,Object\u0026gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate\u0026lt;String,Object\u0026gt; template=new RedisTemplate\u0026lt;\u0026gt;(); //设置连接工厂 template.setConnectionFactory(redisConnectionFactory); //序列化工具 GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); //设置key的序列化 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); //设置value的序列化 template.setValueSerializer(genericJackson2JsonRedisSerializer); template.setHashValueSerializer(genericJackson2JsonRedisSerializer); return template; } } 1 2 @Autowired private RedisTemplate\u0026lt;String,Object\u0026gt; redisTemplate; 注意\n要添加Jackson相关的依赖\n1 2 3 4 5 6 \u0026lt;!-- Jackson 相关的依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.18.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 为了节省内存，一般不会用genericJackson2JsonRedisSerializer，需要存储java对象时，先手动序列化为json格式，然后再存储。获取对象时，在反序列化 Spring默认提供StringRedisTemplate类的key和value都是String的方式序列化 即下面这种写法\nObjectMapper是springmvc默认的用于json处理的工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @SpringBootTest class SpringDataJedisApplicationTests { @Autowired private StringRedisTemplate redisTemplate; private final static ObjectMapper objectMapper = new ObjectMapper(); @Test void testStringJedis() throws JsonProcessingException { Student zhangsan = new Student(\u0026#34;张三\u0026#34;, 50); String zhangsanJson = objectMapper.writeValueAsString(zhangsan);//将对象转为json redisTemplate.opsForValue().set(\u0026#34;zhangsan\u0026#34;,zhangsanJson); Student getZhangsan = objectMapper.readValue(redisTemplate.opsForValue().get(\u0026#34;zhangsan\u0026#34;), Student.class);//将json转为对象 System.out.println(getZhangsan); } } 点评项目 导入 pom文件 修改pom.xml文件。springboot的版本低了，不支持jdk17。要选择更高的版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.18\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.hmdp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hm-dianping\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;hm-dianping\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-pool2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--hutool--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; MybatisPuls配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.hmdp.config; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MybatisConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } @Configuration 该类被标注为 Spring 配置类，意味着 Spring 在启动时会自动加载它。 @Bean mybatisPlusInterceptor() 方法被标注为 @Bean，Spring 会将返回的 MybatisPlusInterceptor 实例 注册到 Spring 容器，以便 MyBatis Plus 进行拦截处理。 MybatisPlusInterceptor MybatisPlusInterceptor 是 MyBatis Plus 提供的插件拦截器，用于增强 MyBatis 的功能（如分页、乐观锁等）。 在这个方法里，我们 添加了分页拦截器，使 MyBatis Plus 支持 MySQL 的分页查询。 PaginationInnerInterceptor(DbType.MYSQL) PaginationInnerInterceptor 是 MyBatis Plus 提供的 分页拦截器，用于自动处理 SQL 语句的分页逻辑。 DbType.MYSQL 指定了数据库类型为 MySQL，确保拦截器能够正确解析 SQL 并应用分页功能。 基于Session实现登录 ![](屏幕截图 2025-02-08 164053.png)\n发送验证码 Request URL:http://localhost:8080/api/user/code?phone=xxxx\nuser/code?phone=xxxx\n请求方式：POST\n无返回值\n登录功能 Request URL:http://localhost:8080/api/user/login\nuser/login\n参数：json\n请求方式：POST\nMybatisPlus extends IService\u0026lt;User\u0026gt; 与 extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; 的关系\n在 MyBatis-Plus 中，IUserService 和 UserServiceImpl 配合使用，分别负责 定义业务接口 和 实现业务逻辑，同时利用 IService 和 ServiceImpl 提供的通用 CRUD 方法，避免手写重复的数据库操作代码。\n1. 代码结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 1. 业务层接口 public interface IUserService extends IService\u0026lt;User\u0026gt; { // 额外的业务方法 } // 2. 业务层实现 @Service @Slf4j public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements IUserService { } //mapper public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { } 2. 详细解析\n① IUserService extends IService\u0026lt;User\u0026gt;\nIService\u0026lt;T\u0026gt; 是 MyBatis-Plus 提供的通用接口，包含常用的 CRUD 方法。 IUserService 继承 IService\u0026lt;User\u0026gt;，自动拥有这些方法，但没有实现。 ② UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements IUserService\nServiceImpl 已经实现了 IService 的 CRUD 方法。 UserServiceImpl 继承 ServiceImpl，自动拥有这些方法，并实现 IUserService，可以增加自定义业务方法。 登录状态校验 不应该往session里放入过多的无用信息\n避免重复校验，用拦截器\nHandlerInterceptor接口 自定义拦截器一般不需要使用@Component注解，需要在config类中手动注册拦截器。而且，Spring 的 @Autowired 依赖注入（DI）仅对 Spring 管理的 Bean 生效，而如果拦截器没有被 Spring 扫描（即没有使用 @Component、@Service、@Controller 等注解），Spring 就不会管理它，也就不能对其中的字段进行自动注入。\n例如\n在LoginInterceptor类里无法注入StringRedisTemplate，则在config类中用形参的形式传入\n自定义拦截器\n1 2 3 4 5 6 7 public class LoginInterceptor implements HandlerInterceptor { private StringRedisTemplate stringRedisTemplate; public LoginInterceptor(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } } config类\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class MvcConfig implements WebMvcConfigurer { @Resource StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor(stringRedisTemplate)) .addPathPatterns(\u0026#34;/**\u0026#34;)//拦截所有请求 .excludePathPatterns(); } } HandlerInterceptor 是 Spring 框架中的一个接口，用于在处理请求的过程中对 HTTP 请求进行拦截和处理。它类似于 Servlet 中的过滤器（Filter），但比过滤器更具针对性，能够更精细地控制请求的处理过程。\n（1）preHandle方法\n触发时机： 在请求到达控制器（Controller）方法之前执行。 返回值： true 表示继续执行请求，false 表示终止请求（不会进入控制器）。 常见用途： 登录认证、权限检查、请求参数校验等。 1 2 3 4 5 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;【preHandle】请求被拦截\u0026#34;); return true; // 继续执行 } （2）postHandle 方法\n触发时机： 在控制器方法执行后，视图渲染之前执行。 常见用途： 修改 ModelAndView 数据、对返回数据进行处理等。 1 2 3 4 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;【postHandle】处理完请求，返回数据前执行\u0026#34;); } （3）afterCompletion 方法\n触发时机： 在视图渲染完成后执行（无论请求是否成功）。 常见用途： 资源清理、日志记录、异常处理等。 1 2 3 4 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;【afterCompletion】请求处理完成\u0026#34;); } 拦截器的注册\n在 Spring Boot 中，可以使用 WebMvcConfigurer 进行拦截器注册：\n.excludePathPatterns() 是 排除某些路径，即使不写 .addPathPatterns(\u0026quot;/**\u0026quot;)，excludePathPatterns() 仍然有效 1 2 3 4 5 6 7 8 9 10 11 12 13 import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()) .addPathPatterns(\u0026#34;/**\u0026#34;) // 拦截所有请求 .excludePathPatterns(\u0026#34;/login\u0026#34;, \u0026#34;/error\u0026#34;); // 排除特定路径 } } **WebMvcConfigurationSupport 和 WebMvcConfigurer ** 维度 WebMvcConfigurationSupport WebMvcConfigurer 作用 完全接管 MVC 配置 扩展默认 MVC 配置 自动配置影响 会禁用 Spring Boot 自动配置，需要手动配置静态资源、消息转换等 不会影响自动配置 适用场景 需要完全控制 MVC 逻辑 仅需部分扩展 MVC 配置 配置方式 继承 WebMvcConfigurationSupport 实现 WebMvcConfigurer 静态资源映射 需要手动配置，否则失效 仍然可用 拦截器、跨域等 需要手动配置 直接扩展 @Resource @Autowired 来源 Java 标准库（javax.annotation.Resource） Spring 框架（org.springframework.beans.factory.annotation.Autowired） 注入方式 默认按名称，若无名称则按类型 默认按类型 是否支持 @Qualifier 可以搭配 @Qualifier 使用 可以搭配 @Qualifier 使用 是否支持 required=false 不支持 支持 是否与 Spring 强绑定 不是，JSR-250 规范的一部分，可用于其他框架 是，属于 Spring 组件 Redis：为解决集群的session在多台tomcat的共享问题 发送验证码 1 2 //存储验证码 key value 有效时间（long） 时间单位（min) stringRedisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY+phone,code,RedisConstants.LOGIN_CODE_TTL, TimeUnit.MINUTES); 将java对象转换成map，使用的是hutool依赖的方法\n1 Map\u0026lt;String, Object\u0026gt; stringObjectMap = BeanUtil.beanToMap(userDTO,new HashMap\u0026lt;\u0026gt;(), CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor((fieldName,fieldValue)\u0026gt;fieldValue.toString())); 生成UUID来作为token\nsession的30min有效期和redis的30min有效期的区别\nsession：每次请求都会重置30分钟有效期，只要用户一直操作，Session不会过期。 有效期固定，即使30分钟内有操作，Token仍会在原定时间过期,所以要做到session类似的效果，需要再拦截器里重置时间 登录：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Override public Result login(LoginFormDTO loginForm, HttpSession session) { //校验验证码 String userCode = stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + loginForm.getPhone()); if(userCode==null||!userCode.toString().equals(loginForm.getCode())){ return Result.fail(\u0026#34;验证码不正确\u0026#34;); } //查询数据库有无用户 User user = lambdaQuery().eq(User::getPhone, loginForm.getPhone()).one(); //不存在 if(user == null){ user=createUserWithPhone(loginForm.getPhone()); log.info(\u0026#34;不存在\u0026#34;); } //存在 UserDTO userDTO = new UserDTO(); BeanUtils.copyProperties(user,userDTO); //保存信息到redis //java对象转为map Map\u0026lt;String, Object\u0026gt; stringObjectMap = BeanUtil.beanToMap(userDTO); //随机生成token作为key，UUID String token = UUID.randomUUID().toString(true); String tokenKey=RedisConstants.LOGIN_USER_KEY+token; //保存到redis stringRedisTemplate.opsForHash().putAll(tokenKey,stringObjectMap); //设置有效期 30min stringRedisTemplate.expire(tokenKey,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES); //返回 return Result.ok(token); } 拦截器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package com.hmdp.utils; import cn.hutool.core.bean.BeanUtil; import cn.hutool.core.util.StrUtil; import com.hmdp.dto.UserDTO; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Map; import java.util.concurrent.TimeUnit; public class LoginInterceptor implements HandlerInterceptor { private StringRedisTemplate stringRedisTemplate; public LoginInterceptor(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { UserHolder.removeUser(); } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //获取请求头中的token String token = request.getHeader(\u0026#34;authorization\u0026#34;); //判断是否为空 if(StrUtil.isBlank(token)){ response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);//401 return false; } //在redis中获取map Map\u0026lt;Object, Object\u0026gt; entries = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY+token);//获取整个map //判断用户是否存在 if(entries == null){ response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);//401 return false; } //将map转为UserDTO UserDTO userDTO = BeanUtil.fillBeanWithMap(entries, new UserDTO(), false); //存在放入ThreadLocal UserHolder.saveUser(userDTO); //刷新有效时间 stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES ); //放行 return true; } } 登录功能的优化 目前的拦截器只对需要登录的请求进行拦截，如果用户存在就刷新一次redis中数据的有效时间。但是当用户进行不需要登录的请求时，无法对redis中的数据进行刷新。所以，需要在此拦截器的前面在加一个拦截器，专门对已登录的用户对其存在redis的数据进行有效时间的刷新。然后第二个拦截器就只做检查用户是否登录。\n第一个拦截器不做拦截，只将请求头中有token的用户通过redis获取用户并对其有效时间进行刷新，再将用户放入TreadLocal里\n第二个拦截器只在ThreadLocal里找用户，如果有就放行，没有就拦截\n在config类里注册拦截器\n可以通过默认的顺序来确定拦截顺序 也可以使用,order()方法，数字越小越先执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Configuration public class MvcConfig implements WebMvcConfigurer { @Resource StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(\u0026#34;/**\u0026#34;)//拦截所有请求 .excludePathPatterns( \u0026#34;/shop/**\u0026#34;, \u0026#34;/voucher/**\u0026#34;, \u0026#34;/shop-type/**\u0026#34;, \u0026#34;/upload/**\u0026#34;, \u0026#34;/blog/hot\u0026#34;, \u0026#34;/user/code\u0026#34;, \u0026#34;/user/login\u0026#34; ).order(1); //默认拦截所有 registry.addInterceptor((new RefreshInterceptor(stringRedisTemplate))).order(0); } } 商户查询缓存 缓存 数据交换的缓冲区，临时存储数据，读写性能较高\n添加redis缓存 解决ObjectMapper不能直接序列化 java.time.LocalDateTime\n因为 Jackson 默认不支持 Java 8 的时间类型。\n添加**jackson-datatype-jsr310 依赖**\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.datatype\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-datatype-jsr310\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 可以创建一个 @Bean 来配置 ObjectMapper：\n1 2 3 4 5 6 7 8 9 10 @Configuration public class JacksonConfig { @Bean public ObjectMapper objectMapper() { ObjectMapper objectMapper = new ObjectMapper(); objectMapper.registerModule(new JavaTimeModule()); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); return objectMapper; } } 或者，在 application.yml 配置：\n1 2 3 4 spring: jackson: serialization: write-dates-as-timestamps: false new TypeReference\u0026lt;List\u0026lt; ShopType\u0026raquo;()不能直接填List\u0026lt; ShopType\u0026gt;吗\n1 2 3 List\u0026lt;ShopType\u0026gt; typeList; ...... typeList =objectMapper.readValue(listJson,new TypeReference\u0026lt;List\u0026lt;ShopType\u0026gt;\u0026gt;(){}); 不能直接填 List\u0026lt; ShopType \u0026gt;.class，因为 Java 的泛型会在运行时被擦除（Type Erasure），导致 ObjectMapper 无法正确推断 List\u0026lt; ShopType \u0026gt; 的具体类型。\n为什么不能使用 List\u0026lt; ShopType \u0026gt;.class？\n在 Java 运行时，List\u0026lt; ShopType \u0026gt;.class 实际上被擦除成 List.class，ObjectMapper 只知道它是一个 List，但不知道里面的元素类型。因此，它无法正确地将 JSON 反序列化为 List\u0026lt; ShopType \u0026gt;。\n为什么 new TypeReference\u0026lt;List\u0026lt; ShopType \u0026raquo;() {} 可行？\nTypeReference\u0026lt; T \u0026gt; 通过 匿名子类 的方式 保留了泛型类型信息，使得 ObjectMapper 可以正确解析 List\u0026lt; ShopType \u0026gt;。\n缓存更新 保证缓存和数据库操作同时成功或失败 单体系统：缓存和数据库操作放在一个事务里\n分布式系统：\n从线程安全来考虑：先删除数据库，在删除缓存（也有可能导致问题），在以超时剔除兜底\n单体系统使用@Transactional注解，\n不需要自定义事务时就不用添加@EnableTransactionManagement ，因为 @EnableAutoConfiguration 会自动为启用事务管理。 需要自定义事务时，才需要显式添加 @EnableTransactionManagement。 缓存穿透 理论 缓存穿透指的是请求的数据既不在缓存中，也不在数据库中，导致每次请求都直接访问数据库，增加了数据库的负担\n常见的解决方法是：\n缓存空数据：将查询结果为空的数据缓存一段时间，避免重复查询数据库。\n布隆过滤器：在缓存中维护一个快速检查数据是否存在的过滤器，避免无效查询数据库。\n布隆过滤器是一种空间效率高的概率型数据结构，用于检测一个元素是否属于某个集合。\n它的工作原理可以简要总结为以下几个步骤：\n哈希函数：布隆过滤器使用多个哈希函数将一个元素映射到一个位数组中的多个位置。每个哈希函数将元素映射到位数组的一个位置（该位置会被标记为 1）。\n添加元素：当一个元素被添加到布隆过滤器时，使用所有的哈希函数对该元素进行哈希，得到多个位置，并将这些位置上的位设置为 1。\n查询元素：当检查一个元素是否在布隆过滤器中时，使用相同的哈希函数对该元素进行哈希，检查所有对应的位是否都为 1。如果所有位都是 1，说明元素可能在集合中；如果其中有任何一个位置为 0，则可以确定该元素不在集合中。\n误判（假阳性）：布隆过滤器的特点是可能出现误判，即判断一个元素在集合中时，实际上它并不在集合中。但不会出现漏判，即判断一个元素不在集合时，实际上它在集合中。误判的概率可以通过调整哈希函数的数量和位数组的大小来控制。\n不存在就真的不存在，存在不一定存在\n修改根据id查询shop ![](屏幕截图 2025-02-13 165311.png)\n若在数据库里面没查到，不能直接返回404。会造成缓存穿透。\n只用了第一种方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public Result queryById(Long id) { //redis里面查 String key= RedisConstants.CACHE_SHOP_KEY+id; Shop shop; String shopJson = stringRedisTemplate.opsForValue().get(key); if(!StrUtil.isBlank(shopJson)){ //若存在直接返回 try { shop = objectMapper.readValue(shopJson, Shop.class); return Result.ok(shop); } catch (JsonProcessingException e) { throw new RuntimeException(e); } } if(!(shopJson==null)){ return Result.fail(\u0026#34;店铺id错误\u0026#34;); } //若不存在，从数据库里面查 shop = getById(id); if(shop==null){ //数据库没查到，将空值写入redis stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES); } //写入redis try { String s = objectMapper.writeValueAsString(shop); stringRedisTemplate.opsForValue().set(key,s,RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); } catch (JsonProcessingException e) { throw new RuntimeException(e); } return Result.ok(shop); } 缓存雪崩 在同一时间，大量的缓存key失效或者redis服务宕机，导致大量的请求直接到达数据库\n解决办法：\n给不同的Key的TTL添加随机值 利用Redis集群提高服务的可用性 给缓存业务添加降级限流策略请求 给业务添加多级缓存 缓存击穿 缓存击穿指的是某个热点 Key 在缓存过期的瞬间，大量并发请求同时查询数据库，导致数据库压力骤增，甚至崩溃。\n解决办法：\n逻辑过期 互斥锁 ![](屏幕截图 2025-02-14 121514.png)\n方案 原理 优点 缺点 适用场景 逻辑过期 缓存数据长期有效，异步更新 访问速度快，不会造成数据库压力，不保证一致性 需要额外的后台任务 长期热点数据 互斥锁 只允许一个线程查询数据库 保证缓存更新安全，保证一致性 需要 Redis 锁，可能影响并发性能 高并发下的缓存击穿 逻辑过期\n新增一个类，包含原来的类和过期时间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 //逻辑过期 private static final ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(10); private Shop queryWithLogicExpire(Long id){ //随机一个数增加到TTL，解决缓存雪崩 Random random = new Random(); long randomTime = random.nextInt(5); String key= RedisConstants.CACHE_SHOP_KEY+id; //redis里查询 String redisDataJson = stringRedisTemplate.opsForValue().get(key); Shop shop; //若未命中 if(StrUtil.isBlank(redisDataJson)){ return null; } //命中 //反序列化，要判断是否过期 RedisData redisData=null; redisData=JSONUtil.toBean(redisDataJson, RedisData.class); JSONObject data =(JSONObject) redisData.getData(); shop=JSONUtil.toBean(data, Shop.class); //未过期，直接返回 LocalDateTime expireTime = redisData.getExpireTime(); if(expireTime.isAfter(LocalDateTime.now())){ return shop; } //过期 //获取锁。获取失败直接返回过期值 String lockKey=RedisConstants.LOCK_SHOP_KEY+id; boolean isLock=tryLock(lockKey); if(isLock){ //双重检测，检测key是不是被其他线程重建了（逻辑时间是否过期） redisDataJson=stringRedisTemplate.opsForValue().get(key); if(redisDataJson!=null){ redisData=JSONUtil.toBean(redisDataJson, RedisData.class); if(redisData.getExpireTime().isAfter(LocalDateTime.now())){ JSONObject shopData =(JSONObject) redisData.getData(); shop=JSONUtil.toBean(shopData, Shop.class); return shop; } } //获取成功开启新线程重建缓存(使用线程池) CACHE_REBUILD_EXECUTOR.submit(()-\u0026gt;{ //重建缓存 try{ saveShopToRedis(id,300L); } catch(Exception e){ e.printStackTrace(); } finally { //释放锁 unLock(lockKey); } }); } return shop; } 互斥锁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 //互斥锁 private Shop queryWithMutex(Long id){ //随机一个数增加到TTL，解决缓存雪崩 Random random = new Random(); long randomTime = random.nextInt(5); String key= RedisConstants.CACHE_SHOP_KEY+id; //redis里查询 String shopJson = stringRedisTemplate.opsForValue().get(key); Shop shop; //若命中 if(!StrUtil.isBlank(shopJson)){ //若存在直接返回 try { shop = objectMapper.readValue(shopJson, Shop.class); return shop; } catch (JsonProcessingException e) { throw new RuntimeException(e); } } //未命中 if(shopJson!=null){//不为空是因为缓存穿透写入了空值(\u0026#34;\u0026#34;) return null; } //重建缓存 //1.获取互斥锁 String lockKey=RedisConstants.LOCK_SHOP_KEY+id; try { boolean isLock = tryLock(lockKey); //2.判断是否获取成功 if(!isLock){ //3.若失败，休眠并重试 try { Thread.sleep(20); } catch (InterruptedException e) { throw new RuntimeException(e); } //使用递归 queryWithMutex(id); } //双重检测：再次检测redis shopJson=stringRedisTemplate.opsForValue().get(key); if(!StrUtil.isBlank(shopJson)){ try { shop = objectMapper.readValue(shopJson, Shop.class); return shop; } catch (JsonProcessingException e) { throw new RuntimeException(e); } } //4.成功，则在数据库里查询 shop = getById(id); //判断数据库里是否存在 //如果不存在，将空值写入redis，避免缓存穿透 if(shop==null){ stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;, RedisConstants.CACHE_NULL_TTL,TimeUnit.SECONDS); return null; } //数据库存在就写在redis try { String s = objectMapper.writeValueAsString(shop); stringRedisTemplate.opsForValue().set(key,s,RedisConstants.CACHE_SHOP_TTL+randomTime, TimeUnit.MINUTES); } catch (JsonProcessingException e) { throw new RuntimeException(e); } } catch (RuntimeException e) { throw new RuntimeException(e); } finally { //释放互斥锁 unLock(lockKey); } return shop; } 封装缓存工具 问题1 不能直接R r=(R) redisData.getData，要使用\n1 2 JSONObject data =(JSONObject) redisData.getData(); res=JSONUtil.toBean(data,rClass); 原因：\nredisData.getData() 返回的是一个 Object 类型的值，它可能是任何类型的数据。因此，直接将它强制转换为 R 类型是不安全的，因为我们无法确定它的实际类型。\n在 RedisData 中，getData() 方法返回的是一个 Object 类型的值，通常它会是一个 JSON 格式的数据。你需要将这个 Object 进一步转换成特定的类型 R。而 JSONObject 是一个可以容纳任意 JSON 数据的对象，它提供了更灵活的方式来处理 JSON 字符串和其他数据类型的转换。\n问题2 写法\n1 2 3 4 5 6 7 8 9 10 public \u0026lt;R, ID\u0026gt; R queryWithPassThrough( String keyPrefix, ID id, Class\u0026lt;R\u0026gt; clazz, Function\u0026lt;ID, R\u0026gt; dbFallBack, Long time, TimeUnit timeUnit ) { // 实现逻辑 } 1. 泛型定义 \u0026lt;R, ID\u0026gt;\nR：方法最终返回的数据类型（例如 User、Shop 等）。 ID：查询条件的唯一标识类型（例如 Long 类型的用户ID、String 类型的订单号等）。 2. 方法名 queryWithPassThrough\n核心目的：解决缓存穿透问题，即在缓存和数据库中都不存在的数据被高频查询时，通过缓存空值避免大量请求穿透到数据库。 3.方法的调用\n1 2 3 4 5 6 7 8 9 cacheUtils .queryWithPassThrough ( RedisConstants.CACHE_SHOP_KEY, id, Shop.class, shopId -\u0026gt; getById(shopId), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); 参数详解\n1. keyPrefix\n类型：String 作用：缓存键的前缀，用于构建唯一的 Redis Key。例如，查询商铺时传入 \u0026quot;cache:shop:\u0026quot;，最终 Redis Key 为 \u0026quot;cache:shop:1\u0026quot;（假设 id=1）。 2. id\n类型：ID 作用：查询数据的唯一标识。例如，用户ID、订单ID等，结合 keyPrefix 生成完整的缓存键。 3. clazz\n类型：Class\u0026lt;R\u0026gt; 作用：指定返回值 R 的类型，用于反序列化 Redis 中存储的 JSON 数据。例如，传入 User.class，将 JSON 反序列化为 User 对象。 4. dbFallBack\n类型：Function\u0026lt;ID, R\u0026gt;\n作用\n：当缓存未命中时，通过此函数从数据库查询数据。这是一个函数式接口，允许调用方自定义数据库查询逻辑。例如：\n1 id -\u0026gt; userMapper.selectById(id) // MyBatis 查询示例 5. time 和 timeUnit\n类型：Long 和 TimeUnit 作用：设置缓存过期时间。例如，time=30, timeUnit=TimeUnit.MINUTES 表示缓存 30 分钟。 问题3 使用逻辑过期时，要提前把数据存到缓存里\n封装代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @Component @Slf4j //缓存工具类 public class CacheUtils { @Resource private StringRedisTemplate stringRedisTemplate; //存放 public void set(String key, Object value, Long time, TimeUnit timeUnit){ stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit); } //set 逻辑过期 public void setWithLogic(String key, Object value, Long time, TimeUnit timeUnit){ RedisData redisData = new RedisData(); redisData.setData(value); redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time))); stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); } //get 解决缓存穿透 public \u0026lt;R,ID\u0026gt; R queryWithPassThrough(String keyPrefix, ID id, Class\u0026lt;R\u0026gt; clazz, Function\u0026lt;ID,R\u0026gt; dbFallBack, Long time, TimeUnit timeUnit){ String key = keyPrefix + id; String json = stringRedisTemplate.opsForValue().get(key); if(StrUtil.isNotBlank(json)){ return JSONUtil.toBean(json, clazz); } //此时json要么为空值要么为null if(json!=null){ return null; } R r = dbFallBack.apply(id); if(r!=null){ // stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(r), time, timeUnit); // 可以调set方法 this.set(key, r, time, timeUnit); } else{ stringRedisTemplate.opsForValue().set(key,\u0026#34;\u0026#34;); } return r; } //get 解决缓存击穿 //获取锁 private boolean tryLock(String key){ Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \u0026#34;1\u0026#34;, RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); } //解锁 private void unLock(String key){ stringRedisTemplate.delete(key); } //逻辑过期 //线程池 private static final ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(10); public \u0026lt;R,ID\u0026gt; R queryWithLogicExpire(String keyPrefix,ID id,Class\u0026lt;R\u0026gt; rClass,Function\u0026lt;ID,R\u0026gt; dbFallBack, Long time, TimeUnit timeUnit){ String key= keyPrefix+id; //redis里查询 String redisDataJson = stringRedisTemplate.opsForValue().get(key); //若未命中 if(StrUtil.isBlank(redisDataJson)){ return null; } //命中 //反序列化，要判断是否过期 RedisData redisData = JSONUtil.toBean(redisDataJson, RedisData.class); //未过期，直接返回 R res = JSONUtil.toBean((JSONObject) redisData.getData(), rClass); LocalDateTime expireTime = redisData.getExpireTime(); if(expireTime.isAfter(LocalDateTime.now())){ return res; } //过期 //获取锁。获取失败直接返回过期值 String lockKey=RedisConstants.LOCK_SHOP_KEY+id; boolean isLock=tryLock(lockKey); if(isLock){ //双重检测，检测key是不是被其他线程重建了（逻辑时间是否过期） redisDataJson=stringRedisTemplate.opsForValue().get(key); if(redisDataJson!=null){ redisData=JSONUtil.toBean(redisDataJson, RedisData.class); if(redisData.getExpireTime().isAfter(LocalDateTime.now())){ JSONObject data =(JSONObject) redisData.getData(); res=JSONUtil.toBean(data,rClass); return res; } } //获取成功开启新线程重建缓存(使用线程池) CACHE_REBUILD_EXECUTOR.submit(()-\u0026gt;{ //重建缓存 //数据库中查询 R apply = dbFallBack.apply(id); try{ setWithLogic(key,apply,time,timeUnit); } catch(Exception e){ e.printStackTrace(); } finally { //释放锁 unLock(lockKey); } }); } return res; } } 优惠券秒杀 全局唯一ID 用redis自增来实现\n其他方法：UUID，雪花算法（snowflake），数据库自增\n八个字节 第一个为符号位，永远为0 中间31位为时间戳。单位为秒，可以用69年。 最后32位为序列号。 不能使用同一个key来存储，所以可以通过日期来再区分key\n生成时间戳\n序列号，实现了每天一个key\n拼接，时间戳为高位，序列号为低位\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Component public class RedisWorker { //UTC时间20250101 0时0分 private final static Long START_TIME = 1735689600L; private final static int COUNT_BITS = 32; @Resource private StringRedisTemplate redisTemplate; //keyPrefix用以区分不同的业务 public long nextId(String keyPrefix) { //1.生成时间戳 LocalDateTime nowTime = LocalDateTime.now(); Long timestamp=nowTime.toEpochSecond(ZoneOffset.UTC)-START_TIME; //2.序列号 //2.1获得当前时间的日期，避免一直使用同一个key // 获取当前日期 LocalDate currentDate = LocalDate.now(); DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy:MM:dd\u0026#34;); // 将当前日期格式化为字符串 String formattedDate = currentDate.format(formatter); //2.2自增长 String key = \u0026#34;icr:\u0026#34;+keyPrefix+\u0026#34;:\u0026#34;+formattedDate; long increment = redisTemplate.opsForValue().increment(key); //3.拼接，时间戳为高位，序列号为低位 //3.1时间戳向左移动32位，留出序列号的位置，再填充序列号 return timestamp \u0026lt;\u0026lt; COUNT_BITS | increment; } } 优惠券实现 将全局id作为订单的id\n实现流程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Resource private ISeckillVoucherService seckillVoucherService; @Resource private RedisIDWorker redisIDWorker; @Override public Result seckillVoucher(Long voucherId) { //查询 SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId); //判断开始、过期时间 if(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) return Result.fail(\u0026#34;还未到开始时间\u0026#34;); if(LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) return Result.fail(\u0026#34;已结束\u0026#34;); //判断库存 if(seckillVoucher.getStock()\u0026lt;1) return Result.fail(\u0026#34;库存不足\u0026#34;); //减少库存 boolean update = seckillVoucherService.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId) .update(); if(update!=true) return Result.fail(\u0026#34;库存不足\u0026#34;); //创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //订单id long orderId = redisIDWorker.nextId(\u0026#34;order:\u0026#34;); voucherOrder.setId(orderId); //用户id voucherOrder.setUserId(UserHolder.getUser().getId()); //代金券id voucherOrder.setVoucherId(voucherId); //存入数据库 save(voucherOrder); //返回订单id return Result.ok(voucherOrder.getId()); } 存在问题1：超卖（多线程并发安全问题）\n常见解决办法：加锁\n乐观锁\n乐观锁假设在并发操作中不太可能发生冲突，因此不会提前加锁，而是在提交时检查数据是否被修改。如果发生冲突，则回滚或重试。\n版本号法\n简化（CAS法）：用查询到的数据本身有没有变化来代替判断版本号是否变化，就不需要版本号了\n改进后代码：\n1 2 3 4 boolean update = seckillVoucherService.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).eq(\u0026#34;stock\u0026#34;,seckillVoucher.getStock()) .update(); 存在问题2：解决了超卖问题，但是请求成功率降低了，库存剩余太多\n改进：不需要让获取的库存没有被修改，只需要让库存大于0就可以\n1 2 3 4 5 //减少库存 boolean update = seckillVoucherService.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).gt(\u0026#34;stock\u0026#34;,0) .update(); 也可以使用分段锁\n悲观锁\n悲观锁假设在并发操作中大概率会发生冲突，因此每次操作时都会先加锁，确保数据不会被其他线程或事务修改。\n一人一单实现 增加一次查询，查询条件为当前用户id和优惠券id，如果存在，就不创建订单\n1 2 3 4 5 6 7 //判断用户是否已经下过单 Long count = query().eq(\u0026#34;userId\u0026#34;, UserHolder.getUser().getId()) .eq(\u0026#34;voucherId\u0026#34;, voucherId) .count(); if(count\u0026gt;0L){ return Result.fail(\u0026#34;用户已经购买过了\u0026#34;); } 存在问题：多线程并发问题\n改进：使用悲观锁，synchronized。使用synchronized并不是锁整个方法，而是锁userId。\nsynchronized (userId.toString().intern())和synchronized (userId.toString()的区别\n原因：userId.toString() 每次调用都会生成一个新的 String 对象（除非 userId 本身是 String）。\n​\t不同线程即使 userId 的值相同，toString() 返回的对象可能不同，导致锁不能正确同步。\n``synchronized`应该加在函数外而不是函数内部\n原因：synchronized 在 @Transactional 之前执行，事务在 createOrder 方法内开启，确保整个下单操作在事务控制下。\n​ 要获取锁，然后提交事务，然后释放锁\n​ 正确写法：\n​ 需要注意的地方：\n如果在 同一个类中直接调用 带有 @Transactional 的方法（如 this.createOrder()），会绕过代理，导致事务失效。\n通过 AopContext.currentProxy() 获取代理对象，并通过代理调用方法：\n1 2 IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createOrder(voucherId); // 通过代理对象调用，触发事务 代理对象调用：proxy.createOrder() 是通过代理对象调用的，因此 @Transactional 生效，事务正常管理。\n锁与事务的协作：synchronized 锁保证了同一用户的请求串行执行，而事务保证了数据库操作的原子性。\n使用前的操作：\n导入依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在启动类或配置类上添加注释 @EnableAspectJAutoProxy(exposeProxy = true)\n1 2 3 4 5 6 7 8 @MapperScan(\u0026#34;com.hmdp.mapper\u0026#34;) @SpringBootApplication @EnableAspectJAutoProxy(exposeProxy = true) public class HmDianPingApplication { public static void main(String[] args) { SpringApplication.run(HmDianPingApplication.class, args); } } 为什么在VoucherOrderServiceImpl类中生成的代理是IVoucherOrderService接口\n这是由 Spring AOP 的动态代理机制决定的\n1. 动态代理的两种实现方式\nSpring 的 AOP 支持两种动态代理方式：\nJDK 动态代理：基于接口生成代理对象，要求目标类必须实现至少一个接口。 CGLIB 代理：通过继承目标类生成子类代理对象，不要求目标类实现接口。 默认情况下：\n如果目标类实现了接口，Spring 优先使用 JDK 动态代理。 如果目标类没有实现接口，则使用 CGLIB 代理。 **@Transactional **注解确实不能直接标注在 private 方法上。\n为什么 @Transactional 不能标注 private 方法？\n1. Spring 事务的代理机制\nSpring 的事务管理基于 AOP（面向切面编程） 实现，具体有两种代理方式：\nJDK 动态代理：代理接口的实现类（要求目标对象实现接口）。 CGLIB 代理：直接代理类（无需接口）。 关键限制： 无论是 JDK 动态代理还是 CGLIB 代理，private 方法都无法被代理拦截。因为：\nprivate 方法在子类（代理类）中不可见，无法被覆盖。 AOP 代理只能拦截 public 或 protected 方法。 2. 事务不生效的后果\n如果强行将 @Transactional 标注在 private 方法上：\n事务不会生效：方法调用不会触发事务的开启、提交或回滚。 无编译错误，但运行时静默失败：Spring 会忽略该注解，导致事务逻辑被跳过。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @Service public class VoucherOrderServiceImpl extends ServiceImpl\u0026lt;VoucherOrderMapper, VoucherOrder\u0026gt; implements IVoucherOrderService { @Resource private ISeckillVoucherService seckillVoucherService; @Resource private RedisIDWorker redisIDWorker; @Override public Result seckillVoucher(Long voucherId) { //查询 SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId); //判断开始、过期时间 if(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) return Result.fail(\u0026#34;还未到开始时间\u0026#34;); if(LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) return Result.fail(\u0026#34;已结束\u0026#34;); //判断库存 if(seckillVoucher.getStock()\u0026lt;1) return Result.fail(\u0026#34;库存不足\u0026#34;); Long userId = UserHolder.getUser().getId(); synchronized (userId.toString().intern()) { //拿到当前对象的代理对象 IVoucherOrderService proxy =(IVoucherOrderService) AopContext.currentProxy(); return proxy.createOrder(voucherId); } } @Transactional public Result createOrder(Long voucherId) { //判断用户是否已经下过单 Long count = query().eq(\u0026#34;userId\u0026#34;,UserHolder.getUser().getId()) .eq(\u0026#34;voucherId\u0026#34;, voucherId) .count(); if(count\u0026gt;0L){ return Result.fail(\u0026#34;用户已经购买过了\u0026#34;); } //减少库存 boolean update = seckillVoucherService.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).gt(\u0026#34;stock\u0026#34;,0) .update(); if(update!=true) return Result.fail(\u0026#34;库存不足\u0026#34;); //创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //订单id long orderId = redisIDWorker.nextId(\u0026#34;order:\u0026#34;); voucherOrder.setId(orderId); //用户id voucherOrder.setUserId(UserHolder.getUser().getId()); //代金券id voucherOrder.setVoucherId(voucherId); //存入数据库 save(voucherOrder); //返回订单id return Result.ok(voucherOrder.getId()); } } ​ 错误写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 @Resource private ISeckillVoucherService seckillVoucherService; @Resource private RedisIDWorker redisIDWorker; @Override public Result seckillVoucher(Long voucherId) { //查询 SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId); //判断开始、过期时间 if(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) return Result.fail(\u0026#34;还未到开始时间\u0026#34;); if(LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) return Result.fail(\u0026#34;已结束\u0026#34;); //判断库存 if(seckillVoucher.getStock()\u0026lt;1) return Result.fail(\u0026#34;库存不足\u0026#34;); Long userId = UserHolder.getUser().getId(); return createOrder(voucherId); } @Transactional public Result createOrder(Long voucherId) { Long userId = UserHolder.getUser().getId(); synchronized (userId.toString().intern()) { //判断用户是否已经下过单 Long count = query().eq(\u0026#34;userId\u0026#34;,userId) .eq(\u0026#34;voucherId\u0026#34;, voucherId) .count(); if(count\u0026gt;0L){ return Result.fail(\u0026#34;用户已经购买过了\u0026#34;); } //减少库存 boolean update = seckillVoucherService.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).gt(\u0026#34;stock\u0026#34;,0) .update(); if(update!=true) return Result.fail(\u0026#34;库存不足\u0026#34;); //创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //订单id long orderId = redisIDWorker.nextId(\u0026#34;order:\u0026#34;); voucherOrder.setId(orderId); //用户id voucherOrder.setUserId(UserHolder.getUser().getId()); //代金券id voucherOrder.setVoucherId(voucherId); //存入数据库 save(voucherOrder); //返回订单id return Result.ok(voucherOrder.getId()); } } 一人一单并发安全问题 加锁只能解决单机情况，不能解决集群模式下的\n模拟集群\n补充：\n如何启动多个服务\n打开运行配置：\n点击 IDEA 右上角的运行配置下拉菜单（默认显示当前运行配置名称）。 选择 Edit Configurations\u0026hellip;。 复制现有配置：\n在左侧列表中找到当前服务的运行配置（如 Spring Boot 或 Application）。 右键点击配置，选择 Copy Configuration。 修改新配置的端口：\n在新复制的配置中，找到 VM options 或 Program arguments。\n添加参数指定不同端口（以 Spring Boot 为例）：\n1 -Dserver.port=8081 # VM options 1 --server.port=8081 # Program arguments 反向代理和负载均衡\n修改nginx.conf文件后，在路径下打开cmd，执行\n1 nginx.exe -s reload 解决办法：分布式锁，多个jvm都使用同一个锁监视器\n分布式锁 满足分布式系统或集群模式下多进程可见并互斥的锁\n分布式系统或集群模式 分布式系统：多个节点（可能跨地域）协同完成目标，节点间通过网络通信（如微服务架构）。 集群模式：多个同构节点（通常在同一局域网）组成逻辑整体，通过冗余提升性能和可用性（如 Kubernetes 集群）。 多进程可见 锁的状态必须能被所有节点或进程感知，例如通过共享存储（如 Redis、ZooKeeper）或一致性协议（如 Raft）实现全局可见性。 互斥 同一时刻只能有一个进程持有锁，确保对共享资源的独占访问。 实现方式：\nmysql：利用mysql本身的互斥锁机制 redis：利用setnx这样的互斥命令 zooKeeper：利用节点的有序性和唯一性来实现 使用redis实现，会有安全问题（死锁），要设置锁的过期时间，到期释放。有非阻塞和阻塞的实现方式\n要在获取锁的同时设置过期时间，保证原子性\n基于Redis实现分布式锁 初级版 创建一个接口\n1 2 3 4 public interface Ilock { public boolean tryLock(Long timeoutSeconds); public void unlock(); } 实现接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import org.springframework.data.redis.core.StringRedisTemplate; import java.util.concurrent.TimeUnit; public class SimpleRedisLock implements Ilock{ private StringRedisTemplate stringRedisTemplate; //业务名称 private String name; private final static String keyPrefix=\u0026#34;lock:\u0026#34;; public SimpleRedisLock(StringRedisTemplate stringRedisTemplate, String name) { this.stringRedisTemplate = stringRedisTemplate; this.name = name; } @Override public boolean tryLock(Long timeoutSeconds) { String lockKey = keyPrefix+name; //获得当前线程的id long id = Thread.currentThread().getId(); Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, \u0026#34;id:\u0026#34; + id, timeoutSeconds, TimeUnit.SECONDS); return Boolean.TRUE.equals(flag); } @Override public void unlock() { stringRedisTemplate.delete(keyPrefix+name); } } 没有被Spring管理\nBoolean自动拆箱成boolean可能会有空指针的风险，所以要使用Boolean.TRUE.equals(flag);\nstringRedisTemplate.opsForValue().setIfAbsent(lockKey,\u0026quot;id:\u0026quot;+id,timeoutSeconds, TimeUnit.SECONDS);StringRedisTemplate\nstringRedisTemplate只能存String类型的，所以要把id转为String，可以使用id+“”来转换\n这个锁是来锁用户的，保证一人一单，所以不光使用业务作为key的前缀，还要加上用户的id\n使用用户的id把创建订单放入一个trycatch里，无论订单创建失败还是成功都要在finally释放锁\n初级版1.0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @Resource private ISeckillVoucherService seckillVoucherService; @Resource private RedisIDWorker redisIDWorker; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result seckillVoucher(Long voucherId) { //查询 SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId); //判断开始、过期时间 if(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) return Result.fail(\u0026#34;还未到开始时间\u0026#34;); if(LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) return Result.fail(\u0026#34;已结束\u0026#34;); //判断库存 if(seckillVoucher.getStock()\u0026lt;1) return Result.fail(\u0026#34;库存不足\u0026#34;); Long userId = UserHolder.getUser().getId(); SimpleRedisLock simpleRedisLock = new SimpleRedisLock(stringRedisTemplate, \u0026#34;order:\u0026#34; + userId); boolean flag = simpleRedisLock.tryLock(15L); if(!flag){ return Result.fail(\u0026#34;不允许重复下单\u0026#34;); } try{ //拿到当前对象的代理对象 IVoucherOrderService proxy =(IVoucherOrderService) AopContext.currentProxy(); return proxy.createOrder(voucherId); } catch (Exception e){ return Result.fail(\u0026#34;未知错误\u0026#34;); } finally { //释放锁 simpleRedisLock.unlock(); } } @Transactional public Result createOrder(Long voucherId) { //判断用户是否已经下过单 Long count = query().eq(\u0026#34;userId\u0026#34;,UserHolder.getUser().getId()) .eq(\u0026#34;voucherId\u0026#34;, voucherId) .count(); if(count\u0026gt;0L){ return Result.fail(\u0026#34;用户已经购买过了\u0026#34;); } //减少库存 boolean update = seckillVoucherService.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId).gt(\u0026#34;stock\u0026#34;,0) .update(); if(update!=true) return Result.fail(\u0026#34;库存不足\u0026#34;); //创建订单 VoucherOrder voucherOrder = new VoucherOrder(); //订单id long orderId = redisIDWorker.nextId(\u0026#34;order:\u0026#34;); voucherOrder.setId(orderId); //用户id voucherOrder.setUserId(UserHolder.getUser().getId()); //代金券id voucherOrder.setVoucherId(voucherId); //存入数据库 save(voucherOrder); //返回订单id return Result.ok(voucherOrder.getId()); } 初级版1.0存在的问题：误释放锁 ![](屏幕截图 2025-03-03 163756.png)\n当线程1获取到锁，因为业务阻塞，超过锁定最大时间限制，锁自动超时释放了，此时线程1的业务还没有完成。\n这时候，线程2尝试获取锁并获取成功，在线程2执行业务的时候，线程1的业务阻塞消失，完成业务，释放掉了锁（线程2的锁）\n由于此时的锁已经被释放了，线程3尝试并获取锁成功，开始执行业务… …\n解决初版存在的问题：\n由于将当前线程的id作为value值存入，所以在释放所之前，要先取出id来看是否为当前线程的锁，这样就可以避免误删。\n多个jvm下，线程的id就有可能重复，所以要用UUID标识一下不同的JVM的线程id（存入的值UUID+线程id）\n代码 初级版2.0：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import cn.hutool.core.lang.UUID; import org.springframework.data.redis.core.StringRedisTemplate; import java.util.concurrent.TimeUnit; public class SimpleRedisLock implements Ilock{ private StringRedisTemplate stringRedisTemplate; //业务名称 private String name; private final static String keyPrefix=\u0026#34;lock:\u0026#34;; private final static String idPrefix = UUID.randomUUID().toString(true); public SimpleRedisLock(StringRedisTemplate stringRedisTemplate, String name) { this.stringRedisTemplate = stringRedisTemplate; this.name = name; } @Override public boolean tryLock(Long timeoutSeconds) { String lockKey = keyPrefix+name; //获得当前线程的id long id = Thread.currentThread().getId(); Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, idPrefix+id, timeoutSeconds, TimeUnit.SECONDS); return Boolean.TRUE.equals(flag); } @Override public void unlock() { String s = stringRedisTemplate.opsForValue().get(keyPrefix + name); if(s.equals(idPrefix+Thread.currentThread().getId())){ stringRedisTemplate.delete(keyPrefix+name); } } } 2.0存在的问题：获取锁和释放锁没有同时进行，要是获取锁过后遇到阻塞，就会出问题\n","date":"2025-01-15T00:00:00Z","permalink":"https://suechinrry.github.io/p/redis/","title":"Redis"},{"content":"数据结构和算法 数组 数组是存放在连续内存空间上的相同类型数据的集合。\n下标从0开始 内存空间的地址是连续的 数组的元素不能删除只能覆盖 二分法 使用前提：有序数组，无重复元素\n二分法 left，right，middle只根据条件来改变left或right的值，middle的值自然会改变\n写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。\n两种写法的区别while循环条件不同，r的赋值不同\n写法1：[left, right]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int search(int[] nums, int target) { int l=0; int r=nums.length-1; int mid=0; while(l\u0026lt;=r){ mid= l + ((r - l) / 2); if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid-1; } else{ return mid; } } return -1; } } 将mid=（l+r）/2换成mid= l + ((r - l) / 2)的原因:当l和r都很大时，会导致溢出。\n写法2：[left,right)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int search(int[] nums, int target) { int l=0; int r=nums.length; int mid=0; while(l\u0026lt;r){ mid=l+(r-l)/2; if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid; } else{ return mid; } } return -1; } } 相关题目 35.搜索插入位置 N 暴力解法\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public int searchInsert(int[] nums, int target) { for(int i=0;i\u0026lt;nums.length;i++){ // 一旦发现大于或者等于target的num[i]，那么i就是我们要的结果 if(nums[i]\u0026gt;=target){ return i; } } return nums.length; } } 二分查找\n写法1：[l,r]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int searchInsert(int[] nums, int target) { int l=0; int r=nums.length-1; int mid=0; while(l\u0026lt;=r){ mid=l+(r-l)/2; if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid-1; } else{ return mid; } } //数组中未找到target元素 //target在数组所有元素之后，[left, right]是右闭区间，需要返回 right +1 return r+1; } } r 指针已经指向了数组中小于 target 的最后一个元素的位置\n34.在排序数组中查找元素的第一个和最后一个位置 含有重复元素时\n用两个二分法来查找左右边界\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int[] searchRange(int[] nums, int target) { int[] answer = new int[]{-1, -1}; int l = 0; int r = nums.length - 1; int mid = 0; int leftBorder = -1; int rightBorder = -1; // 查找左边界 while (l \u0026lt;= r) { mid = l + (r - l) / 2; if (nums[mid] \u0026gt;= target) { r = mid - 1; leftBorder = mid; // 更新左边界 } else { l = mid + 1; } } // 查找右边界 l = 0; r = nums.length - 1; while (l \u0026lt;= r) { mid = l + (r - l) / 2; if (nums[mid] \u0026lt;= target) { l = mid + 1; rightBorder = mid; // 更新右边界 } else { r = mid - 1; } } // 情况一：目标值不存在 if (leftBorder == -1 || rightBorder == -1 || nums[leftBorder] != target) { return new int[]{-1, -1}; } // 返回目标值的开始位置和结束位置 return new int[]{leftBorder, rightBorder}; } } 查找左边界的核心目标\n我们需要找到目标值在数组中最早出现的位置。在二分查找的过程中，r 和 l 指针会根据当前查找的值是否符合目标来不断调整。关键的思想是通过“收缩查找范围”来逼近目标值的左边界。\n为什么使用 r 来确定左边界？\n当 nums[mid] \u0026gt;= target 时，我们可以确定目标值可能在当前位置 mid 或 mid 左侧的区间。 为什么是左侧？ 因为我们正在寻找左边界，而且数组是非递减顺序排列的。如果当前 nums[mid] 大于或等于目标值，目标值可能出现在 mid 或它的左边。 例如，如果目标值是 8，在 [5, 7, 7, 8, 8, 10] 这样的数组中，8 出现了两次。你需要确定目标值第一个出现的位置。即便在 mid 处找到了 8，我们还需要继续查找 mid 左侧，看看是否存在更早的 8。 收缩右边界 r = mid - 1，这样我们就会继续在 mid 左边的区间进行查找。因为目标值可能出现在 mid 或它的左侧。 更新 leftBorder = r： 当 nums[mid] \u0026gt;= target 时，目标值在 mid 或它的左边，所以我们更新 r 位置为左边界的位置（r 逐步逼近目标值的左侧）。 这时，leftBorder 记录的其实是当前 mid 左侧的一个边界，而不是 mid 本身。因为如果 nums[mid] \u0026gt;= target，说明目标值应该在 mid 或左边，所以我们更新左边界为 r，以便后续判断是否存在更小的值。 leftBorder == -1\nleftBorder 用来记录目标值在数组中最左边的出现位置。如果 leftBorder 为 -1，意味着在查找左边界的过程中没有找到目标值。也就是说，目标值在数组中不存在，所以此时应该返回 [-1, -1]，表示目标值不存在。\n为什么是 -1？ 在查找过程中，leftBorder 的初始值是 -1，只有当查找到目标值时才会更新 leftBorder。如果最终没有找到目标值，leftBorder 仍然保持为 -1。 nums[leftBorder] != target\n这一部分检查在找到的 leftBorder 位置是否真的等于目标值 target。也就是说，即使 leftBorder 不等于 -1，我们还需要确认 nums[leftBorder] 这个位置的值是否确实是目标值 target。\n为什么要做这个检查？ 可能出现一种情况：假设目标值并未出现在数组中，但二分查找的过程可能仍然会更新 leftBorder 为某个位置。为了确保 leftBorder 位置的值确实是目标值，我们需要进行额外的检查。只有当 nums[leftBorder] == target 时，才说明 leftBorder 是有效的目标值出现位置。 组合解释：\n如果 leftBorder == -1，表示目标值在数组中不存在，所以直接返回 [-1, -1]。 如果 rightBorder == -1，同样表示目标值在数组中不存在，所以也返回 [-1, -1]。 如果 nums[leftBorder] != target，说明 leftBorder 虽然不是 -1，但是找到了一个错误的位置，或者在 leftBorder 位置并没有找到目标值。因此，也应该返回 [-1, -1]。 为什么是 leftBorder = mid 而不是 leftBorder = r？\n查找左边界的目标是找到 目标值第一次出现的位置。在二分查找的过程中，当 nums[mid] \u0026gt;= target 时，说明目标值可能在 mid 或它的左边，所以我们需要继续往左侧查找，并且 mid 是可能的左边界。\n如果 nums[mid] \u0026gt;= target，说明目标值可能在 mid 位置或其左边\n：\n为什么mid 是可能的左边界？ 假设数组是 [5, 7, 7, 8, 8, 10]，我们要查找目标值 8。 当我们在 mid = 3 时，发现 nums[mid] == 8，这时我们知道 8 出现在 mid 位置或者它左边的位置。 因为我们要找到 第一次出现的位置，即最左边的目标值，所以即使在 mid 处找到了目标值，我们仍然需要继续向左查找。 69.x 的平方根 N 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int mySqrt(int x) { if (x == 0) return 0; int l=1; int r=x; int mid=0; while(l\u0026lt;=r){ mid=l+(r-l)/2; if(x/mid\u0026lt;mid){ r=mid-1; } else if(x/mid\u0026gt;mid){ l=mid+1; } else{ return mid; } } return r; } } 为了防止溢出，将mid*mid\u0026gt;x换位x/mid\u0026lt;mid 二分查找最终会使得 l \u0026gt; r，此时区间 [l, r] 会被缩小到一个无法继续分割的状态。此时，r 就是比 sqrt(x) 小的最大整数。 367.有效的完全平方数 移除元素 移除元素 N 暴力解法，两层for循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int removeElement(int[] nums, int val) { int n=nums.length; for(int i=0;i\u0026lt;n;i++){ if(nums[i]==val){ for(int j=i+1;j\u0026lt;n;j++){ nums[j-1]=nums[j]; } n--;//长度减一 i--;//下一次还是得从现在这个位置开始。 } } return n; } } 双指针\nfast遍历整个数组，slow用来指向更新新数组下标的位置。\n其实count没必要\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int removeElement(int[] nums, int val) { int slow=0; int count=0; for(int fast=0;fast\u0026lt;nums.length;fast++){ if(nums[fast]!=val){//不是目标数就进行更新，将下标为fast的值更新到下标slow nums[slow]=nums[fast]; slow++; count++; } //与目标值相等就不做处理，等待被覆盖 } return count; } } 相关题目 26.删除排序数组中的重复项 N 第一个元素不用处理，从第二个元素开始。所以slow的初始值是1，fast的初始值也为1，而且为了避免下标溢出，将nums[fast]!=nums[fast+1]换成nums[fast]!=nums[fast-1]。\nslow 指针始终指向下一个应该放置去重后元素的位置。每当我们遇到一个不重复的元素时，我们就将其放入 nums[slow] 位置，并且增加 slow 的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int slow=1; for(int fast=1;fast\u0026lt;nums.length;fast++){ if(nums[fast]!=nums[fast-1]){ nums[slow]=nums[fast]; slow++; } } return slow; } } 283.移动零 844.比较含退格的字符串 ==对于数组，直接使用 length，不加括号。==\n==对于字符串，使用 length() 方法，记得加括号。==\nStringBuilder 和 StringBuffer 可变的字符串类\n如果你只在单线程环境中操作字符串，使用 StringBuilder 更好，因为它性能更优。 如果你需要在多线程环境中操作同一个字符串对象，使用 StringBuffer，它提供了线程安全保证，但性能可能稍逊色。 以下类和接口可以用作栈：\nStack（传统栈类） Deque（推荐，使用 ArrayDeque 或 LinkedList 实现） LinkedList（兼容双端队列和栈） 自定义栈（数组或链表实现） 线程安全的栈（如 Collections.synchronizedDeque 包装的 Deque） 优先推荐使用 Deque 接口（如 ==ArrayDeque==），因为它性能更高且设计更现代化。\n栈相关方法：\nArrayDeque 实现了 Deque 接口，支持以下与栈相关的方法：\npush(E e)\n将元素压入栈（队列的头部）。 等同于 addFirst()。 时间复杂度：O(1)。 1 2 3 ArrayDeque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push(1); // 入栈 stack.push(2); // 入栈 pop()\n移除并返回栈顶元素（队列的头部元素）。 等同于 removeFirst()。 如果栈为空，调用此方法会抛出 NoSuchElementException。 时间复杂度：O(1)。 1 int element = stack.pop(); // 出栈，输出 2 peek()\n返回栈顶元素，但不移除它（查看队列的头部元素）。 等同于 peekFirst()。 如果栈为空，返回 null。 时间复杂度：O(1)。 1 int top = stack.peek(); // 查看栈顶元素，输出 1 isEmpty()\n判断栈是否为空。 时间复杂度：O(1)。 1 boolean isEmpty = stack.isEmpty(); // 判断栈是否为空 size()\n返回栈的元素个数。 时间复杂度：O(1)。 1 int size = stack.size(); // 返回栈的大小 977.有序数组的平方 N 暴力\n1 2 3 4 5 6 7 8 9 class Solution { public int[] sortedSquares(int[] nums) { for(int i=0;i\u0026lt;nums.length;i++){ nums[i]=nums[i]*nums[i]; } Arrays.sort(nums); return nums; } } 双指针排序\n左边从0开始，右边从length-1开始。\n因为数组是按照非递减排列的，所以说右边的数大于等于左边。\n==这道题求的是平方大的。==\nnums[left]与nusm[right]相加。大于0，则说明right下标的数要大些；小于0，就说明left下标的绝对值要大些\n==这个比较相加大于0小于0代替比较两个数的平方的大小。==\n比较完后，将得到的结构写道新的数组里，而且还要移动左或者右指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int[] sortedSquares(int[] nums) { int left=0; int right=nums.length-1; int[] answer=new int[nums.length]; int i=nums.length-1; while(left\u0026lt;=right){ if(nums[left]+nums[right]\u0026lt;0){ answer[i]=nums[left]*nums[left]; left++; } else{ answer[i]=nums[right]*nums[right]; right--; } i--; } return answer; } } 若仅仅按照大小排列则为以下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int[] sortedArray(int[] nums) { int left = 0; // 左指针 int right = nums.length - 1; // 右指针 int[] answer = new int[nums.length]; // 用于存储结果 int i = 0; // 从结果数组的开头开始填充 while (left \u0026lt;= right) { if (nums[left] \u0026lt;= nums[right]) { answer[i] = nums[left]; left++; } else { answer[i] = nums[right]; right--; } i++; } return answer; } } 长度最小的子数组 长度最小的子数组 这道题的子数组数连续的\n暴力\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int minSubArrayLen(int target, int[] nums) { int sum=0; int min=Integer.MAX_VALUE; for(int i=0;i\u0026lt;nums.length;i++){ sum=0; for(int j=i;j\u0026lt;nums.length;j++){ sum+=nums[j]; if(sum\u0026gt;=target){ min=Math.min(min,j-i+1); break; } } } return min==Integer.MAX_VALUE?0:min; } } 滑动窗口（双指针）\n只用一个for循环，这个循环是确定终止位置的\nfor循环里，for(int end=0; end\u0026lt;nums.length; end++)；扩大窗口，每次通过 sum+=nums[end] 增加当前窗口的和。\n如果加上后大于target，则开始移动start。（开始移动是指移动到sum不满足大于target为止，所以需要用while而不是if，并且每次移动后都要记录最小子数组的长度）\n为什么start不需要再每次for循环时重置为0？\n因为，sum满足大于target这个条件时（ while(sum\u0026gt;=target)）,会尝试减小，减小值为当前nums[start]，sum的和就不会再包含当前start下标的值了。如果每次循环都重置为0，就会删除sum本身不包含的数，会导致错误。\n下面是gpt的回答：\n为什么 start 不需要在每次 for 循环时重置为 0？\n滑动窗口的动态调整机制 在滑动窗口算法中，start 的作用是 调整窗口的左边界，使得当前窗口的和 (sum) 满足问题的要求（比如大于等于 target）。 一旦 sum \u0026gt;= target，我们通过移动 start（即增加 start 的值），缩小窗口的左边界，同时从 sum 中减去 nums[start] 的值。这种操作是基于当前窗口的状态进行的，不需要从头（start = 0）重新开始调整。 如果每次外层循环都重置 start = 0，就会丢失滑动窗口算法的核心逻辑，即在前一次窗口调整的基础上继续调整，这会导致重复计算和逻辑错误。 为什么不能删除不属于当前窗口的值？ 如果 start 被重置为 0，我们就会尝试减去 nums[start]（比如 nums[0]），但这些值可能已经被移出了当前窗口（while(sum \u0026gt;= target) 的过程中已经移除了）。此时的 sum 已经不再包含这些值，减去它们会导致错误的计算。 动态收缩窗口 vs 重置窗口 动态收缩窗口：每次 sum \u0026gt;= target 时，只通过增加 start 的方式调整窗口，确保窗口和始终基于当前窗口的实际范围。 重置窗口：如果每次外层循环都将 start 重置为 0，就会导致每次都从头开始重新计算窗口。这种做法会让算法丢失滑动窗口的高效性，同时也会引入逻辑错误（因为 sum 不包含窗口外的值）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int minSubArrayLen(int target, int[] nums) { int start=0; int sum=0; int min=Integer.MAX_VALUE; for(int end=0;end\u0026lt;nums.length;end++){ sum+=nums[end]; while(sum\u0026gt;=target){ sum-=nums[start]; min=Math.min(min,end-start+1); start++; } } return min==Integer.MAX_VALUE?0:min; } } 相关题目 904.水果成篮 N 先减少水果数量，再检查是否移除水果键。不然会移除一个不存在的键而报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int totalFruit(int[] fruits) { int left=0; int max=Integer.MIN_VALUE; Map\u0026lt;Integer,Integer\u0026gt; fruitsMap=new HashMap\u0026lt;\u0026gt;(); for(int right=0;right\u0026lt;fruits.length;right++){ fruitsMap.put(fruits[right],fruitsMap.getOrDefault(fruits[right],0)+1); while(fruitsMap.size()\u0026gt;2){ fruitsMap.put(fruits[left],fruitsMap.get(fruits[left])-1); if(fruitsMap.get(fruits[left])==0){ fruitsMap.remove(fruits[left]); } left++; } max=Math.max(max,right-left+1); } return max; } } 76.最小覆盖子串 N 螺旋矩阵2 59. 螺旋矩阵 II - 力扣（LeetCode） N 确定好外循环，外循环是一共要转多少圈，n为奇数时单独的一个数不算一圈。这样的话奇数和偶数就统一了，所需圈数都为n/2\n内循环，转一次圈需要四个。采用左闭右开[ )。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int[][] generateMatrix(int n) { int[][] answer = new int[n][n]; int loop=0; int startx=0,starty=0; int i=0,j=0; int offset=1,count=1; while(loop\u0026lt;n/2){//n为偶数就刚好转n/2圈 //向右,目前i=0,j=starty for(j=starty;j\u0026lt;n-offset;j++){ answer[startx][j]=count++; } //向下，目前j=n-offset了 for(i=startx;i\u0026lt;n-offset;i++){ answer[i][j]=count++; } //向左,目前i=n-offset，j=n-offset for(;j\u0026gt;starty;j--){ answer[i][j]=count++; } //向上，目前i=n-offset，j=starty for(;i\u0026gt;startx;i--){ answer[i][j]=count++; } startx++; starty++; offset++; loop++; } if(n%2!=0){//n为奇数，还需要加上最里面的一个单独的数 answer[startx][starty]=count; } return answer; } } 类似题目 54.螺旋矩阵 N 如果min(rows, columns)为偶数，则不需要在最后单独考虑矩阵最中间位置的赋值 如果min(rows, columns)为奇数 m\u0026gt;n，会剩下一个中间列 m\u0026lt;n，会剩下一个中间行 m=n，会剩下一个中间数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public List\u0026lt;Integer\u0026gt; spiralOrder(int[][] matrix) { ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); int m = matrix[0].length; int n = matrix.length; int a = 0; int i,j; int startx = 0, starty = 0; int loop = Math.min(m, n) / 2; int mid = loop; int offset = 1; while (loop \u0026gt; 0){ for(j = starty; j \u0026lt; m -offset; j++) list.add(matrix[startx][j]); for(i = startx; i \u0026lt; n - offset; i++) list.add(matrix[i][j]); for(; j \u0026gt; starty; j--) list.add(matrix[i][j]); for(; i \u0026gt; startx; i--) list.add(matrix[i][j]); startx++; starty++; loop--; offset++; } if ((Math.min(m,n)%2) != 0 ) { if(m \u0026gt; n){ for ( j = mid; j \u0026lt; mid + m - n + 1; ++j) { list.add(matrix[mid][j]); } } else { for ( i = mid; i \u0026lt; mid + n - m + 1; ++i) { list.add(matrix[i][mid]); } } } return list; } } 剑指Offer 29.顺时针打印矩阵 将ArrayList转换成int数组\n1 res.stream().mapToInt(Integer::intValue).toArray(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public int[] spiralArray(int[][] array) { if (array == null || array.length == 0 || array[0].length == 0) { return new int[0]; } List \u0026lt;Integer\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); int m=array.length,n=array[0].length; int startx=0,starty=0; int i,j; int loop=0,offset=1; while(loop\u0026lt;Math.min(m,n)/2){ for(j=starty;j\u0026lt;n-offset;j++){ res.add(array[startx][j]); } for(i=startx;i\u0026lt;m-offset;i++){ res.add(array[i][j]); } for(;j\u0026gt;starty;j--){ res.add(array[i][j]); } for(;i\u0026gt;startx;i--){ res.add(array[i][j]); } loop++; startx++; starty++; offset++; } if(Math.min(m,n)%2!=0){ if(m\u0026gt;n){//中间列 for(int k=n/2;k\u0026lt;n/2+m-n+1;k++){ res.add(array[k][starty]); } } else{//m\u0026lt;n中间行 m=n中间元素 for(int k=m/2;k\u0026lt;m/2+n-m+1;k++){ res.add(array[startx][k]); } } } return res.stream().mapToInt(Integer::intValue).toArray(); } } 链表 关于链表 链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。\n种类 单链表 双链表 循环链表 存储方式 链表在内存中可不是连续分布的。\n链表是通过指针域的指针链接在内存中各个节点。\n操作 删除节点\n203. 移除链表元素 - 力扣（LeetCode）\n不用虚拟节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public ListNode removeElements(ListNode head, int val) { //若头节点符合删除头节点 while(head!=null\u0026amp;\u0026amp;head.val==val){ head=head.next; } ListNode cur=head; while(cur!=null\u0026amp;\u0026amp;cur.next!=null){ if(cur.next.val==val){ cur.next=cur.next.next; } else{ cur=cur.next; } } return head; } } 使用虚拟节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode removeElements(ListNode head, int val) { ListNode dummy=new ListNode(Integer.MAX_VALUE,head); ListNode cur=dummy; while(cur.next!=null){ if(cur.next.val==val){ cur.next=cur.next.next; } else{ cur=cur.next; } } return dummy.next; } } 添加节点\n707. 设计链表 206. 反转链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode reverseList(ListNode head) { ListNode res = null; // 反转后的链表头初始化为null ListNode cur = head; // 当前节点指向原链表的头 while (cur != null) { // 循环直到遍历完整个链表 ListNode temp = cur; // 保存当前节点 cur = cur.next; // 移动cur到下一个节点 temp.next = res; // 当前节点指向反转后的链表头 res = temp; // 更新反转链表头 } return res; // 返回反转后的链表头 } } . while(cur.next != null) -\u0026gt; while(cur != null) 原代码：\n1 while (cur.next != null) 问题：\ncur.next != null 只会判断当前节点的下一个节点是否存在，如果是最后一个节点，cur.next 为 null，则会跳出循环，导致最后一个节点没有被反转并丢失。 我们希望遍历链表中的所有节点，不论是中间节点还是最后一个节点，所以条件应该是 cur != null。 修改后：\n1 while (cur != null) 这样，循环会继续直到 cur 为 null，即遍历整个链表，保证所有节点都能被反转。\n为什么一定要将cur后移一位的操作放在对res操作之前\nChatGPT 说： ChatGPT\n将 cur 后移一位的操作放在对 res 操作之前的主要原因是为了 保护链表的完整性，避免丢失未处理的节点。如果不先移动 cur 而直接修改 res，链表中的某些节点可能会失去引用，导致链表断裂或顺序错乱。\n核心逻辑： 在反转链表过程中，cur 指针是负责遍历原链表的。如果在处理 res（反转链表的头指针）之前没有将 cur 后移到下一个节点，当当前节点的 next 被修改时，原链表中后续节点的信息会丢失。\n示例分析 假设我们有一个链表：\n1 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; null 正确操作顺序（先移动 cur）： 当前节点是 cur = 1，res = null。\n保存当前节点：temp = cur（即 temp = 1）。 先移动 cur：cur = cur.next（即 cur = 2）。 修改当前节点指针：temp.next = res（即 1.next = null）。 更新反转链表头：res = temp（即 res = 1）。 结果：\n1 2 rust复制编辑原链表：2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; null 反转链表：1 -\u0026gt; null 当前节点是 cur = 2，重复以上操作，直到整个链表被反转。\n错误操作顺序（不先移动 cur）： 当前节点是 cur = 1，res = null。\n保存当前节点：temp = cur（即 temp = 1）。 直接修改 temp.next：temp.next = res（即 1.next = null）。 更新反转链表头：res = temp（即 res = 1）。 然后移动 cur：cur = cur.next（此时 cur = 1.next）。 问题：\n1.next 已经被修改为 null，因此 cur = cur.next 得到的是 null。 原链表中剩余的节点 2 -\u0026gt; 3 -\u0026gt; 4 被丢失。 最终导致链表断裂，无法继续处理。\n24. 两两交换链表中的节点 half-N 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public ListNode swapPairs(ListNode head) { ListNode dumy=new ListNode(); dumy.next=head; ListNode first; ListNode second; ListNode cur=dumy; while(cur.next!=null\u0026amp;\u0026amp;cur.next.next!=null){ first=cur.next; second=cur.next.next; cur.next=second; first.next=second.next; second.next=first; cur=first; } return dumy.next; } } 为什么需要dummy节点？\ndummy节点作为占位头节点，可以统一处理链表头部的交换操作，避免头节点变化时的特殊处理。例如，当原链表只有两个节点时，交换后的新头节点是第二个节点，dummy.next能直接指向它。\ncur.next!=null\u0026amp;\u0026amp;cur.next.next!=null为什么循环终止条件必须是这个?\n要交换两个节点，必须保证当前节点后至少有两个节点。若cur.next或cur.next.next为空，说明剩余节点不足两个，无需继续交换。\ncur = first的作用是什么？\n交换完成后，cur移动到已处理部分的末尾（即原第一个节点），作为下一对节点的前驱节点。例如，交换1-\u0026gt;2后，cur移动到1的位置，以便处理后续的3-\u0026gt;4\ntodo可以用递归做\n19. 删除链表的倒数第 N 个结点 不使用虚拟头节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if(head==null||head.next==null){ return null; } int count=0; ListNode cur=head; while(cur!=null){ cur=cur.next; count++; } cur=head; count=count-n; //处理删除值为头节点 if(count==0){ return head.next; } while(count\u0026gt;1){ cur=cur.next; count--; } cur.next=cur.next.next; return head; } } 不使用虚拟头节点，所以要处理head为空和head.next为空的特殊情况 删除head所指的节点，要单独处理 使用虚拟头节点+双指针 双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dumy=new ListNode(); dumy.next=head; ListNode fast=dumy; ListNode slow=dumy; for(int i=0;i\u0026lt;n;i++){ fast=fast.next; } while(fast.next!=null){ slow=slow.next; fast=fast.next; } slow.next=slow.next.next; return dumy.next; } } 循环结束条件必须是fast.next!=null,这样fast才会停在最后一个有效节点上，slow才会停在待删除节点前一个节点。\n如果是fast！=null的话，fast会多走一次，停在最后一个有效节点的next上（即null上）。\n面试题 02.07. 链表相交 方法一 headA.next==null\u0026amp;\u0026amp;headB.next==null时，也有成立的可能（例如headA为[1]，headB为[1]），不应该直接返回null。\n计算链表长度的循环条件\ncount=0，循环条件为cur!=null。若是使用cur.next!=null，则会停止在最后一个有效节点上，count=长度-1。\n遍历链表的循环条件\n​ 正确循环：fast!=null\u0026amp;\u0026amp;slow!=null，这样不会遗漏最后一个有效节点\n​ 错误循环：fast.next!=null\u0026amp;\u0026amp;slow.next!=null，这样只是停在了最有一个有效节点，但是不能操作这个有效节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA==null||headB==null){ return null; } int countA=0,countB=0; ListNode cur=headA; while(cur!=null){ cur=cur.next; countA++; } cur=headB; while(cur!=null){ cur=cur.next; countB++; } ListNode fast; ListNode slow; if(countA\u0026gt;countB){ fast=headA; slow=headB; } else{ fast=headB; slow=headA; } for(int i=0;i\u0026lt;Math.max(countA,countB)-Math.min(countA,countB);i++){ fast=fast.next; } while(fast!=null\u0026amp;\u0026amp;slow!=null){ if(fast==slow){ return fast; } fast=fast.next; slow=slow.next; } return null; } } 方法二 todo合并链表实现同步移动\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // p1 指向 A 链表头结点，p2 指向 B 链表头结点 ListNode p1 = headA, p2 = headB; while (p1 != p2) { // p1 走一步，如果走到 A 链表末尾，转到 B 链表 if (p1 == null) p1 = headB; else p1 = p1.next; // p2 走一步，如果走到 B 链表末尾，转到 A 链表 if (p2 == null) p2 = headA; else p2 = p2.next; } return p1; } } 142. 环形链表 II 使用快慢指针，快指针会和慢指针在环内相遇。这样可以判断有无环\n计算循环链表入口\n![](屏幕截图 2025-01-31 185531.png)\nfast指针一次走两格\nslow指针一次走一格\n相遇时，fast走x+y+n(y+z)，slow走x+y。并且fast走的时slow的两倍\n即(x + y) * 2 = x + y + n (y + z)\n两边消掉一个（x+y）: x + y = n (y + z)\n因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。\n所以要求x ，将x单独放在左面：x = n (y + z) - y ,整理后得x = (n - 1) (y + z) + z\n当n等于1时，x=z。说明两个指针，一个指向head（index1），另一个指向fast和slow的相遇点（index2），当两指针相遇，index1就是环形入口。\nn如果大于1，就是fast指针在环形转n圈之后才遇到 slow指针。\n其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。\n循环条件\n为什么循环条件是fast!=null\u0026amp;\u0026amp;fast.next!=null而不是fast.next!=null\u0026amp;\u0026amp;slow!=null 当 fast 为空时，仍可能尝试访问 fast.next，导致 NullPointerException。 slow 是否为空并不会影响 fast 的运行逻辑，加入 slow != null 没有意义。 在处理链表问题时，如果循环条件是基于 fast.next != null 进行判断，一定要带上 fast != null，否则可能会导致 NullPointerException 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast=head; ListNode slow=head; while(fast!=null\u0026amp;\u0026amp;fast.next!=null){ fast=fast.next.next; slow=slow.next; if(fast==slow){ ListNode index1=head; ListNode index2=fast; //在相遇点 while(index1!=index2){ index1=index1.next; index2=index2.next; } return index1; } } return null; } } 哈希表 常见的三种结构 数组\nset （集合）\nmap(映射)\nHashMap的一些常用方法\n添加元素\nput(K key, V value)：添加键值对，如果 key 已存在，则更新对应的 value。 putIfAbsent(K key, V value)：仅在 key 不存在时添加键值对。 获取元素\nget(Object key)：根据 key 获取对应的 value，若不存在返回 null。 getOrDefault(Object key, V defaultValue)：获取 key 对应的 value，若不存在则返回默认值。 删除元素\nremove(Object key)：删除指定 key 的键值对。 remove(Object key, Object value)：仅当 key 和 value 同时匹配时删除。 替换元素\nreplace(K key, V newValue)：替换指定 key 对应的 value，若 key 不存在则无操作。 replace(K key, V oldValue, V newValue)：仅当 key 和旧值匹配时才替换为新值。 检查键或值\ncontainsKey(Object key)：检查是否包含指定的 key。 containsValue(Object value)：检查是否包含指定的 value。 Map 状态\nsize()：返回 HashMap 中键值对的数量。 isEmpty()：检查 HashMap 是否为空。 批量操作\nputAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m)：将另一个 Map 的所有键值对添加到当前 HashMap 中。 clear()：清空所有键值对。 获取视图\nkeySet()：返回 HashMap 中所有 key 的 Set 视图。 values()：返回 HashMap 中所有 value 的 Collection 视图。 entrySet()：返回 HashMap 中所有键值对的 Set 视图（Map.Entry 对象集合）。 遍历HashMap\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.util.HashMap; import java.util.Map; public class HashMapTraversal { public static void main(String[] args) { HashMap\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(1, \u0026#34;Apple\u0026#34;); map.put(2, \u0026#34;Banana\u0026#34;); map.put(3, \u0026#34;Cherry\u0026#34;); // 方法 1：使用 keySet 遍历 key，再通过 get() 获取 value System.out.println(\u0026#34;遍历 keySet:\u0026#34;); for (Integer key : map.keySet()) { System.out.println(\u0026#34;Key: \u0026#34; + key + \u0026#34;, Value: \u0026#34; + map.get(key)); } // 方法 2：使用 entrySet 遍历 key 和 value（推荐） System.out.println(\u0026#34;\\n遍历 entrySet:\u0026#34;); for (Map.Entry\u0026lt;Integer, String\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue()); } // 方法 3：使用 forEach (Java 8+) System.out.println(\u0026#34;\\n使用 forEach:\u0026#34;); map.forEach((key, value) -\u0026gt; System.out.println(\u0026#34;Key: \u0026#34; + key + \u0026#34;, Value: \u0026#34; + value)); // 方法 4：使用 Iterator 遍历 entrySet System.out.println(\u0026#34;\\n使用 Iterator:\u0026#34;); var iterator = map.entrySet().iterator(); while (iterator.hasNext()) { var entry = iterator.next(); System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue()); } } } 242. 有效的字母异位词 getOrDefault(sChar[i],0)使用这个方法时，要带两个参数 如果 t 中的字符不在 s 中，直接返回 false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public boolean isAnagram(String s, String t) { Map\u0026lt;Character,Integer\u0026gt; sMap=new HashMap\u0026lt;\u0026gt;(); char[] sChar=s.toCharArray(); char[] tChar=t.toCharArray(); if(sChar.length!=tChar.length){ return false; } for(int i=0;i\u0026lt;sChar.length;i++){ sMap.put(sChar[i],sMap.getOrDefault(sChar[i],0)+1); } for(int i=0;i\u0026lt;tChar.length;i++){ // 如果 t 中的字符不在 s 中，直接返回 false if (!sMap.containsKey(tChar[i])) { return false; } sMap.put(tChar[i],sMap.get(tChar[i])-1); if(sMap.get(tChar[i])==0){ sMap.remove(tChar[i]); } } return sMap.isEmpty(); } } 相关题目 383. 赎金信 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean canConstruct(String ransomNote, String magazine) { char[] mChar=magazine.toCharArray(); char[] rChar=ransomNote.toCharArray(); Map\u0026lt;Character,Integer\u0026gt; rMap=new HashMap\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;rChar.length;i++){ rMap.put(rChar[i],rMap.getOrDefault(rChar[i],0)+1); } for(int i=0;i\u0026lt;mChar.length;i++){ if(!rMap.containsKey(mChar[i])){ continue; } rMap.put(mChar[i],rMap.get(mChar[i])-1); if(rMap.get(mChar[i])==0){ rMap.remove(mChar[i]); } } return rMap.isEmpty(); } } 49. 字母异位词分组 - 力扣（LeetCode） N\n将strs[i]都用Arrays.sort排个序，如果排序结果相同，说明它们应该在同一个list里 返回结果时不用遍历map，直接用new ArrayList\u0026lt;\u0026gt;(sMap.values()); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Map \u0026lt;String,List\u0026lt;String\u0026gt;\u0026gt; sMap=new HashMap\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;strs.length;i++){ char[] schar=strs[i].toCharArray(); Arrays.sort(schar); String sortString=new String(schar); if(!sMap.containsKey(sortString)){ List\u0026lt;String\u0026gt; list=new ArrayList\u0026lt;\u0026gt;(); sMap.put(sortString,list); } sMap.get(sortString).add(strs[i]); } return new ArrayList\u0026lt;\u0026gt;(sMap.values()); } } 438. 找到字符串中所有字母异位词 - 力扣（LeetCode）N\n暴力\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); int pLen = p.length(); int sLen = s.length(); // 边界条件：p长度大于s，直接返回空列表 if (pLen \u0026gt; sLen) { return result; } // 将p排序后的字符串作为目标键 char[] pChar = p.toCharArray(); Arrays.sort(pChar); String pSorted = new String(pChar); // 滑动窗口遍历s for (int i = 0; i \u0026lt;sLen - pLen+1; i++) { // 修正循环条件 char[] window = new char[pLen]; // 每次创建新的数组 for (int j = 0; j \u0026lt; pLen; j++) { // 直接取pLen长度的字符 window[j] = s.charAt(i + j); } Arrays.sort(window); String windowSorted = new String(window); // 如果匹配p的排序结果，记录索引 if (windowSorted.equals(pSorted)) { result.add(i); } } return result; } } todo滑动窗口\n349. 两个数组的交集 由于要去重，所以用HashSet来存储结果\n使用HashSet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int[] intersection(int[] nums1, int[] nums2) { Set\u0026lt;Integer\u0026gt; nums1Set=new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Integer\u0026gt; res=new HashSet\u0026lt;\u0026gt;(); for(int i:nums1){ nums1Set.add(i); } for(int i:nums2){ if(nums1Set.contains(i)){ res.add(i); } } int[] resNums=new int[res.size()]; int index=0; for(int i:res){ resNums[index++]=i; } return resNums; } } 1 2 3 4 5 6 7 8 9 10 11 12 //方法1：将结果集合转为数组 return resSet.stream().mapToInt(x -\u0026gt; x).toArray(); //方法2：另外申请一个数组存放setRes中的元素,最后返回数组 int[] arr = new int[resSet.size()]; int j = 0; for(int i : resSet){ arr[j++] = i; } return arr; Hash数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int[] intersection(int[] nums1, int[] nums2) { int[] hash1=new int[1001]; int[] hash2=new int[1001]; List\u0026lt;Integer\u0026gt; resList=new ArrayList\u0026lt;\u0026gt;(); for(int v:nums1){ hash1[v]++; } for(int v:nums2){ hash2[v]++; } for(int i=0;i\u0026lt;hash1.length;i++){ if(hash1[i]\u0026gt;0\u0026amp;\u0026amp;hash2[i]\u0026gt;0){ if(!resList.contains(i)){//避免重复添加 resList.add(i); } } } int[] resNums=new int[resList.size()]; int index=0; for(int i:resList){ resNums[index++]=i; } return resNums; } } 相关题目 350. 两个数组的交集 II 找两个数组的交集，重复几个 x 就返回几个 x\n主要代码\n1 2 3 4 5 if(hash1[i]\u0026gt;0\u0026amp;\u0026amp;hash2[i]\u0026gt;0){ for(int count=0;count\u0026lt;Math.min(hash1[i],hash2[i]);count++){ resList.add(i); } } 完整代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int[] intersect(int[] nums1, int[] nums2) { int[] hash1=new int[1001]; int[] hash2=new int[1001]; List\u0026lt;Integer\u0026gt; resList=new ArrayList\u0026lt;\u0026gt;(); for(int v:nums1){ hash1[v]++; } for(int v:nums2){ hash2[v]++; } for(int i=0;i\u0026lt;hash1.length;i++){ if(hash1[i]\u0026gt;0\u0026amp;\u0026amp;hash2[i]\u0026gt;0){ for(int count=0;count\u0026lt;Math.min(hash1[i],hash2[i]);count++){ resList.add(i); } } } int[] resNums=new int[resList.size()]; int index=0; for(int i:resList){ resNums[index++]=i; } return resNums; } } 202. 快乐数 一个数，只有两种结果：一种是经过有限次循环，变为1；另一种是经过有限次过后，会一种重复一个数，会一直循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean isHappy(int n) { Set\u0026lt;Integer\u0026gt; resSet=new HashSet\u0026lt;\u0026gt;(); while(!resSet.contains(n)\u0026amp;\u0026amp;n!=1){ resSet.add(n); int sum=0; while(n\u0026gt;0){ sum+=(n%10)*(n%10); n/=10; } n=sum; } return n==1; } } 1. 两数之和 使用hashMap\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer,Integer\u0026gt; numsMap=new HashMap\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; resList=new ArrayList\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;nums.length;i++){ if(numsMap.containsKey(target-nums[i])){ resList.add(i); resList.add(numsMap.get(target-nums[i])); } else{ numsMap.put(nums[i],i); } } int[] res=new int[resList.size()]; int index=0; for(int v:resList){ res[index++]=v; } return res; } } 使用双指针\n使用firstFound变量，避免相同值的覆盖\n如输入 nums = [3, 3]，target = 6，不使用这个变量会将 res[0] 和 res[1] 都赋值为相同的索引。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public int[] twoSum(int[] nums, int target) { int left=0; int right=nums.length-1; int[] res=new int[2]; int[] temp=new int[nums.length]; for(int i=0;i\u0026lt;nums.length;i++){ temp[i]=nums[i]; } Arrays.sort(temp); while(left\u0026lt;right){ if(temp[left]+temp[right]\u0026gt;target){ right--; } else if(temp[left]+temp[right]\u0026lt;target){ left++; } else{ break; } } boolean firstFound = false; for(int i=0;i\u0026lt;nums.length;i++){ if(nums[i]==temp[left]\u0026amp;\u0026amp;!firstFound){ res[0]=i; firstFound=true; } if(nums[i]==temp[right]){ res[1]=i; } } return res; } } 454. 四数相加 II N 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { Map\u0026lt;Integer,Integer\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); int count=0; for(int i=0;i\u0026lt;nums1.length;i++){ for(int j=0;j\u0026lt;nums2.length;j++){ int temp=nums1[i]+nums2[j]; map.put(temp,map.getOrDefault(temp,0)+1); } } for(int i=0;i\u0026lt;nums3.length;i++){ for(int j=0;j\u0026lt;nums4.length;j++){ int temp=-(nums3[i]+nums4[j]); if(map.containsKey(temp)){ count += map.get(temp); } } } return count; } } 不需要减小map中value的值。\n在 if(map.containsKey(temp)) 里只增加 count 一次，但如果 map.get(temp) \u0026gt; 1，说明这个 temp 可能匹配多次，所以 count 应该增加 map.get(temp) 的值，而不是简单的 count++。\n15. 三数之和 N 双指针法\nnums.length - 2 确保 至少有两个数可以作为 left 和 right，防止数组越界。\nif(nums[0]\u0026gt;0) return res;//可去，但是这种情况(排序后的第一个数大于0)没必要继续操作\n第一个去重操作，避免第一个数重复 if(i\u0026gt;0\u0026amp;\u0026amp;nums[i]==nums[i-1]) continue;\n第二个去重操作，避免第二个第三个数重复 while(left\u0026lt;right\u0026amp;\u0026amp;nums[left]==nums[left+1]) left++; while(left\u0026lt;right\u0026amp;\u0026amp;nums[right]==nums[right-1]) right--; 这个位置的left和right正是重复的最后一个数，必须在移动一次才是新的数left++; right\u0026ndash;; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); if(nums[0]\u0026gt;0) return res;//可去，但是这种情况没必要继续操作 for(int i=0;i\u0026lt;nums.length-2;i++){ int left=i+1; int right=nums.length-1; //第一个去重操作，避免第一个数重复 if(i\u0026gt;0\u0026amp;\u0026amp;nums[i]==nums[i-1]) continue; while(left\u0026lt;right){ int temp=nums[i]+nums[left]+nums[right]; if(temp\u0026gt;0){ right--; } else if(temp\u0026lt;0){ left++; } else{ List\u0026lt;Integer\u0026gt; tempList=new ArrayList\u0026lt;\u0026gt;(); tempList.add(nums[i]); tempList.add(nums[left]); tempList.add(nums[right]); res.add(tempList); //1.第二个去重操作，避免第二个第三个数重复 while(left\u0026lt;right\u0026amp;\u0026amp;nums[left]==nums[left+1]) left++; while(left\u0026lt;right\u0026amp;\u0026amp;nums[right]==nums[right-1]) right--; //2.这个位置的left和right正是重复的最后一个数，必须在移动一次才是新的数 left++; right--; } } } return res; } } 18. 四数之和 对于例子\nnums = [1000000000, 1000000000, 1000000000, 1000000000]\ntarget = -294967296\nint temp = nums[i] + nums[j] + nums[left] + nums[right];和long temp = (long) (nums[i] + nums[j] + nums[left] + nums[right]);都不正确。因为int类型的取值范围为 [-2^31, 2^31 - 1]，所以前者会溢出；后者仍然会 溢出，因为 强制转换 (long) 的时机不对。Java 的 运算优先级 规则会导致 int 先相加，再转换为 long，这样就没办法避免溢出了。\n正确写法： long temp = (long) nums[i] + nums[j] + nums[left] + nums[right];\n四数之和和前面三数之和区别不大，三数用了一个for循环，再通过while循环使双指针游走来确定三个数；而四数通过两个for循环来确定前两个数，再通过while循环确定后两个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for(int i=0;i\u0026lt;nums.length-3;i++){ if(i\u0026gt;0\u0026amp;\u0026amp;nums[i]==nums[i-1]) continue; for(int j=i+1;j\u0026lt;nums.length-2;j++){ if(j\u0026gt;i+1\u0026amp;\u0026amp;nums[j]==nums[j-1]) continue; int left=j+1; int right=nums.length-1; while(left\u0026lt;right){ long temp = (long) nums[i] + nums[j] + nums[left] + nums[right]; if(temp\u0026gt;target){ right--; } else if(temp\u0026lt;target){ left++; } else{ List\u0026lt;Integer\u0026gt; tempList=new ArrayList\u0026lt;\u0026gt;(); tempList.add(nums[i]); tempList.add(nums[j]); tempList.add(nums[left]); tempList.add(nums[right]); res.add(tempList); while(left\u0026lt;right\u0026amp;\u0026amp;nums[left]==nums[left+1]) left++; while(left\u0026lt;right\u0026amp;\u0026amp;nums[right]==nums[right-1]) right--; left++; right--; } } } } return res; } } 字符串 344. 反转字符串 双指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public void reverseString(char[] s) { int left=0; int right=s.length-1; while(left\u0026lt;right){ char temp=s[left]; s[left]=s[right]; s[right]=temp; left++; right--; } } } 库函数：String reversed = new StringBuilder(str).reverse().toString(); // 使用 StringBuilder 作为流的一部分\n541. 反转字符串 II 双指针fa\n计算：\ni left right 0 0 k-1 2k-1 1 2k 3k-1 4k-1 2 4k 5k-1 6k-1 3 6k 7k-1 8k-1 left的表达式： left=2 * k * i;\nright的表达式：right=2 * k * (i+1)-k-1;\n最后剩余的部分分类讨论\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public String reverseStr(String s, int k) { char[] schars=s.toCharArray(); int rest=schars.length%(2*k); int counts=schars.length/(2*k); for(int i=0;i\u0026lt;counts;i++){ int left=2*k*i; int right=2*k*(i+1)-1-k; while(left\u0026lt;right){ char temp=schars[left]; schars[left]=schars[right]; schars[right]=temp; left++; right--; } } int left,right; if(rest\u0026lt;k){ left=2*k*counts; right=schars.length-1; } else{ left=2*k*counts; right=2*k*(counts+1)-1-k; } while(left\u0026lt;right){ char temp=schars[left]; schars[left]=schars[right]; schars[right]=temp; left++; right--; } return new String(schars); } } 54. 替换数字 注意格式 StringBuiilder效率高，多线程不安全。StringBuffer反之。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.Scanner; public class Main{ public static String changeNumber(String s){ StringBuilder res=new StringBuilder(); char[] sChars=s.toCharArray(); for(int i=0;i\u0026lt;sChars.length;i++){ if(sChars[i]\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;sChars[i]\u0026lt;=\u0026#39;z\u0026#39;){ res.append(sChars[i]); } else{ res.append(\u0026#34;number\u0026#34;); } } return res.toString(); } public static void main(String[] args){ Scanner scanner = new Scanner(System.in); String s = scanner.next(); System.out.println(changeNumber(s)); scanner.close(); } } 151. 反转字符串中的单词 不调用库函数\n调用库函数\n[右旋字符串](55. 右旋字符串（第八期模拟笔试）) substring方法提取字符串的子串，返回值是子字符串\nsubstring(int start) 从这个下标到字符串结尾\nsubstring(int start , int end) 从start下标到end-1。包前不包后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.Scanner; public class Main{ private static String function(String s,int k){ StringBuilder sb=new StringBuilder(); sb.append(s.substring(s.length()-k)); sb.append(s.substring(0,s.length()-k)); return sb.toString(); } public static void main(String[] args){ Scanner in = new Scanner(System.in); int n = Integer.parseInt(in.nextLine()); String s = in.nextLine(); System.out.println(function(s,n)); in.close(); } } 28. 找出字符串中第一个匹配项的下标 使用滑动窗口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int strStr(String haystack, String needle) { int length=needle.length(); StringBuilder sb=new StringBuilder(); int start=0; for(int end=0;end\u0026lt;haystack.length();end++){ sb.append(haystack.charAt(end)); if(sb.length()\u0026gt;length){ sb.deleteCharAt(0); start++; } if(sb.toString().equals(needle)){ return start; } } return -1; } } 使用KMP\n459. 重复的子字符串 N 不需要把原字符串s一节一节的截出来，直接用获得的子字符串组成一个和原字符串长度相等的字符串，比较这两个就可以 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public boolean repeatedSubstringPattern(String s) { int len = s.length() / 2; for (int i = 1; i \u0026lt;= len; i++) { // 子字符串的长度 if (s.length() % i != 0) { continue; } String sub = s.substring(0, i); if (verify(sub, s)) { return true; } } return false; } private static boolean verify(String sub, String s) { int subLen = sub.length(); int counts = s.length() / subLen; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; counts; i++) { sb.append(sub); } return sb.toString().equals(s); } } 栈和队列 栈（Stack 类） 压栈push弹栈pop\nJava 提供了 java.util.Stack 类来实现**后进先出（LIFO）**的数据结构。\n1 Stack 类的方法 1 2 3 4 5 6 7 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(10); // 入栈 stack.push(20); stack.push(30); System.out.println(stack.pop()); // 出栈 -\u0026gt; 30 System.out.println(stack.peek()); // 查看栈顶 -\u0026gt; 20 System.out.println(stack.empty()); // 是否为空 -\u0026gt; false push(E item): 入栈 pop(): 出栈（删除并返回栈顶元素） peek(): 查看栈顶元素 empty(): 判断栈是否为空 search(Object o): 返回元素的 1-based 位置 2 Stack 的缺点 Stack 继承 Vector，是 同步 的，性能较低。 建议使用 Deque（ArrayDeque）代替 Stack。 3 使用 Deque 作为栈 1 2 3 4 5 6 7 Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push(10); stack.push(20); stack.push(30); System.out.println(stack.pop()); // 30 System.out.println(stack.peek()); // 20 System.out.println(stack.isEmpty()); // false 为什么使用 Deque？\nArrayDeque 比 Stack 更高效，因为 Stack 继承 Vector，带有同步锁，影响性能。 Deque 非同步，适用于单线程环境，多线程需要 ConcurrentLinkedDeque。 相关题目 232. 用栈实现队列 用两个栈模拟队列，只在pop和peek使用两个栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class MyQueue { private Deque\u0026lt;Integer\u0026gt; stack1; // 负责 push 操作 private Deque\u0026lt;Integer\u0026gt; stack2; // 负责 pop 和 peek 操作 public MyQueue() { stack1 = new ArrayDeque\u0026lt;\u0026gt;(); stack2 = new ArrayDeque\u0026lt;\u0026gt;(); } // 直接将元素推入 stack1 public void push(int x) { stack1.push(x); } // 只有 stack2 为空时才将 stack1 的元素倒入 stack2 public int pop() { if (stack2.isEmpty()) { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } return stack2.pop(); } // 获取队列前端元素，逻辑与 pop 类似，但不删除元素 public int peek() { if (stack2.isEmpty()) { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } } return stack2.peek(); } // 只有两个栈都为空时，队列才为空 public boolean empty() { return stack1.isEmpty() \u0026amp;\u0026amp; stack2.isEmpty(); } } 20. 有效的括号 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public boolean isValid(String s) { Deque\u0026lt;Character\u0026gt; stack=new ArrayDeque\u0026lt;\u0026gt;(); char[] sChars=s.toCharArray(); for(int i=0;i\u0026lt;sChars.length;i++){ if(!stack.isEmpty()\u0026amp;\u0026amp;sChars[i]==\u0026#39;)\u0026#39;){ if(stack.peek()!=\u0026#39;(\u0026#39;){ return false; } else{ stack.pop(); } } else if(!stack.isEmpty()\u0026amp;\u0026amp;sChars[i]==\u0026#39;]\u0026#39;){ if(stack.peek()!=\u0026#39;[\u0026#39;){ return false; } else{ stack.pop(); } } else if(!stack.isEmpty()\u0026amp;\u0026amp;sChars[i]==\u0026#39;}\u0026#39;){ if(stack.peek()!=\u0026#39;{\u0026#39;){ return false; } else{ stack.pop(); } } else{ stack.push(sChars[i]); } } return stack.isEmpty(); } } 2\n1047. 删除字符串中的所有相邻重复项 双指针\nnew String(ch, 0, slow) 的含义是：\n从 ch 数组的索引 0 开始 取 slow 个字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String removeDuplicates(String s) { char[] ch = s.toCharArray(); int fast = 0; int slow = 0; while(fast \u0026lt; s.length()){ // 直接用fast指针覆盖slow指针的值 ch[slow] = ch[fast]; // 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了 if(slow \u0026gt; 0 \u0026amp;\u0026amp; ch[slow] == ch[slow - 1]){ slow--; }else{ slow++; } fast++; } return new String(ch,0,slow); } } 栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public String removeDuplicates(String s) { Deque\u0026lt;Character\u0026gt; stack=new ArrayDeque\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;s.length();i++){ char ch=s.charAt(i); if(!stack.isEmpty()\u0026amp;\u0026amp;ch==stack.peek()){ stack.pop(); continue; } stack.push(ch); } StringBuilder sb=new StringBuilder(); while(!stack.isEmpty()){ sb.append(stack.pop()); } return sb.reverse().toString(); } } 150. 逆波兰表达式求值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public int evalRPN(String[] tokens) { Deque\u0026lt;Integer\u0026gt; stack=new ArrayDeque\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;tokens.length;i++){ if(tokens[i].equals(\u0026#34;+\u0026#34;)){ int num2=stack.pop(); int num1=stack.pop(); stack.push(num1+num2); } else if(tokens[i].equals(\u0026#34;-\u0026#34;)){ int num2=stack.pop(); int num1=stack.pop(); stack.push(num1-num2); } else if(tokens[i].equals(\u0026#34;*\u0026#34;)){ int num2=stack.pop(); int num1=stack.pop(); stack.push(num1*num2); } else if(tokens[i].equals(\u0026#34;/\u0026#34;)){ int num2=stack.pop(); int num1=stack.pop(); stack.push(num1/num2); } else{ int num=Integer.parseInt(tokens[i]); stack.push(num); } } return stack.pop(); } } 队列 添加offer删除poll\n队列（Queue） 是一种 FIFO（先进先出） 的数据结构，常用于任务调度、缓冲区管理、消息队列等场景。\nJava 提供了多个队列的实现，主要包括：\n1. Queue 接口 Queue 接口位于 java.util 包中，继承自 Collection，提供基本的队列操作方法：\n1 public interface Queue\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; 常见实现类：\nLinkedList（基于链表） PriorityQueue（优先级队列） ArrayDeque（双端队列） 主要方法\n方法 描述 offer(E e) 添加元素，成功返回 true，失败返回 false poll() 取出并删除队首元素，若队列为空返回 null remove() 取出并删除队首元素，若队列为空抛出异常 peek() 获取队首元素，但不删除，队列为空返回 null element() 获取队首元素，但不删除，队列为空抛出异常 2. Deque（双端队列） Deque（双端队列）支持 从两端插入和删除，比 Queue 更灵活。\nDeque 的常见实现：\nLinkedList（基于链表） ArrayDeque（基于数组，效率更高） 主要方法\n方法 作用 addFirst(E e) 头部插入元素 addLast(E e) 尾部插入元素 removeFirst() 删除头部元素 removeLast() 删除尾部元素 getFirst() 获取头部元素但不删除 getLast() 获取尾部元素但不删除 3. PriorityQueue（优先队列） PriorityQueue 是基于堆实现的优先队列，默认按最小堆排序（最小值在队首）。\n​\n1 2 // 创建一个默认的 PriorityQueue（小顶堆） PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); 1 2 // 使用 Comparator 实现大顶堆 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Comparator.reverseOrder()); 不允许存入 null\n非线程安全\n默认升序，可传入 Comparator 自定义排序\n4. BlockingQueue（阻塞队列） BlockingQueue 适用于多线程并发场景，可在队列满/空时阻塞线程。\n常见实现\n类 说明 ArrayBlockingQueue 基于数组的有界队列 LinkedBlockingQueue 基于链表的无界队列 PriorityBlockingQueue 带优先级的阻塞队列 DelayQueue 只有到期元素才会被取出的队列 相关题目 225. 用队列实现栈 使用两个队列\nint peekNum=queue1.peek();\nqueue2.offer(queue1.poll());\n这一步不能少，虽然不删，但一定要将queue1的元素移到queue2去。不然会影响顺序\n例如：栈 ：4 3 2\n​ 进行peek()\n​ 正确做法: queue1：2 3 4， queue2为空\n​ 移动，queue1：4，queue2：2 3\n​ 获取查询返回值4，并将4从queue1移到queue2中，queue2：2 3 4\n​ 再将queue2中的移回queue1。queue1：2 3 4。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class MyStack { private Deque\u0026lt;Integer\u0026gt; queue1; private Deque\u0026lt;Integer\u0026gt; queue2; public MyStack() { queue1=new ArrayDeque\u0026lt;\u0026gt;(); queue2=new ArrayDeque\u0026lt;\u0026gt;(); } public void push(int x) { queue1.offer(x); } public int pop() { while(queue1.size()\u0026gt;1){ queue2.offer(queue1.poll()); } int popNum=queue1.poll(); while(!queue2.isEmpty()){ queue1.offer(queue2.poll()); } return popNum; } public int top() { while(queue1.size()\u0026gt;1){ queue2.offer(queue1.poll()); } int peekNum=queue1.peek(); queue2.offer(queue1.poll()); while(!queue2.isEmpty()){ queue1.offer(queue2.poll()); } return peekNum; } public boolean empty() { return queue1.isEmpty()\u0026amp;\u0026amp;queue2.isEmpty(); } } 239. 滑动窗口最大值 N 347. 前 K 个高频元素 N (a, b) -\u0026gt; 表达式\n如果 返回值 \u0026lt; 0，a 排在 b 前面。\n如果 返回值 \u0026gt; 0，b 排在 a 前面。\n如果 返回值 == 0，顺序不变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer,Integer\u0026gt; hashMap=new HashMap\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;nums.length;i++){ hashMap.put(nums[i],hashMap.getOrDefault(nums[i],0)+1); } //大顶堆 PriorityQueue\u0026lt;int[]\u0026gt; pq= new PriorityQueue\u0026lt;\u0026gt;((pair1, pair2) -\u0026gt; pair2[1] - pair1[1]); for(Map.Entry\u0026lt;Integer,Integer\u0026gt; entry:hashMap.entrySet()){ int[] kAndv={entry.getKey(),entry.getValue()}; pq.offer(kAndv); } int[] res=new int[k]; for(int i=0;i\u0026lt;k;i++){ res[i]=pq.poll()[0]; } return res; } } 二叉树 度的定义 一个节点的度（Degree of a Node）： 指的是该节点的子节点（直接孩子）的数量。 一棵树的度（Degree of a Tree）： 指的是树中所有节点的最大度数。\n二叉树的定义 用链表实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } 二叉树的种类 满二叉树 只有度为0或者为2的节点\n深度为k的满二叉树的节点个数为：2^k-1\n完全二叉树 完全二叉树的定义如下：\n在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。\n优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。\n二叉搜索树 前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树\n(左小右大)\n若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 平衡二叉搜索树 平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树\n且具有以下性质：\n它是一棵空树 或 它的左右两个子树的高度差的绝对值不超过1 并且左右两个子树都是一棵 平衡二叉树。 二叉树的遍历方式 深度优先遍历(使用栈或递归) 这里前中后，其实指的就是中间节点的遍历顺序\n前序遍历144. 二叉树的前序遍历 顺序：中左右\n递归法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); function(root,res); return res; } private void function(TreeNode node,List\u0026lt;Integer\u0026gt; res){ if(node==null) return; res.add(node.val); if(node.left!=null){ function(node.left,res); } if(node.right!=null){ function(node.right,res); } return; } } 迭代法\n非统一\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Deque\u0026lt;TreeNode\u0026gt; stack=new ArrayDeque\u0026lt;\u0026gt;(); if(root==null) return res; stack.push(root); while(!stack.isEmpty()){ TreeNode node=stack.pop(); if(node==null) continue; res.add(node.val); if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); } return res; } } 统一迭代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Deque\u0026lt;TreeNode\u0026gt; stack=new LinkedList\u0026lt;\u0026gt;(); if(root==null) return res; stack.push(root); while(!stack.isEmpty()){ TreeNode node=stack.pop();//最开始已经被弹出栈了 if(node!=null){ //前序 放入栈的顺序为：右左中 if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); stack.push(node); stack.push(null); } else{ res.add(stack.pop().val);//所以下一个出栈的就是未处理的值，而不是null } } return res; } } 中序遍历94. 二叉树的中序遍历 顺序：左中右\n递归法\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); function(root,res); return res; } private void function(TreeNode node,List\u0026lt;Integer\u0026gt; res){ if(node==null) return; function(node.left,res); res.add(node.val); function(node.right,res); } } 迭代法\n非统一 N\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null){ return result; } Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()){ if (cur != null){ stack.push(cur); cur = cur.left; }else{ cur = stack.pop(); result.add(cur.val); cur = cur.right; } } return result; } } 统一迭代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Deque\u0026lt;TreeNode\u0026gt; stack=new LinkedList\u0026lt;\u0026gt;(); if(root==null) return res; stack.push(root); while(!stack.isEmpty()){ TreeNode node=stack.pop(); if(node!=null){ //中序入栈顺序为：右中左 if(node.right!=null) stack.push(node.right); stack.push(node); stack.push(null); if(node.left!=null) stack.push(node.left); } else{ res.add(stack.pop().val); } } return res; } } 后序遍历145. 二叉树的后序遍历 顺序：左右中\n递归法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); function(root,res); return res; } private void function(TreeNode node,List\u0026lt;Integer\u0026gt; res){ if(node==null) return; if(node.left!=null){ function(node.left,res); } if(node.right!=null){ function(node.right,res); } res.add(node.val); return; } } 迭代法\n非统一\n顺序为中右左，在经过翻转得到左右中。\n反转方法：Collections.reverse(res);，这个方法没有返回值，只会反转res列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null){ return res; } Deque\u0026lt;TreeNode\u0026gt; stack=new ArrayDeque\u0026lt;\u0026gt;(); stack.push(root); while(!stack.isEmpty()){ TreeNode node=stack.pop(); res.add(node.val); if(node.left!=null){ stack.push(node.left); } if(node.right!=null){ stack.push(node.right); } } Collections.reverse(res); return res; } } 统一迭代\nArrayDeque类不允许放入null值，而LinkedList可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Deque\u0026lt;TreeNode\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); if(root==null) return res; stack.push(root); while(!stack.isEmpty()){ TreeNode node=stack.pop(); if(node!=null){ //后序放入栈需要 中右左 stack.push(node); stack.push(null); if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); } else{ res.add(stack.pop().val); } } return res; } } 广度优先遍历（队列） 层次遍历 迭代法\n使用队列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); if(root==null) return res; queue.offer(root); while(!queue.isEmpty()){ int len=queue.size(); List\u0026lt;Integer\u0026gt; tempList=new ArrayList\u0026lt;\u0026gt;(); while(len\u0026gt;0){ TreeNode node=queue.poll(); tempList.add(node.val); if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); len--; } res.add(tempList); } return res; } } 递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); levelOrderHelper(root, 0, res); // 从根节点开始，层次为0 return res; } // 递归函数 private void levelOrderHelper(TreeNode node, int level, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res) { if (node == null) { return; } // 如果当前层没有元素，添加一个新的列表 if (res.size() \u0026lt;= level) { res.add(new ArrayList\u0026lt;\u0026gt;()); } // 将当前节点的值添加到对应层的列表中 res.get(level).add(node.val); // 递归遍历左子树和右子树，层数加1 levelOrderHelper(node.left, level + 1, res); levelOrderHelper(node.right, level + 1, res); } } 相关题目 107. 二叉树的层序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrderBottom(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; que=new ArrayDeque\u0026lt;\u0026gt;(); if(root==null) return res; que.offer(root); while(!que.isEmpty()){ int len=que.size(); List\u0026lt;Integer\u0026gt; tempList=new ArrayList\u0026lt;\u0026gt;(); while(len\u0026gt;0){ TreeNode node=que.poll(); tempList.add(node.val); if(node.left!=null) que.offer(node.left); if(node.right!=null) que.offer(node.right); len--; } res.add(tempList); } Collections.reverse(res); return res; } } 107. 二叉树的层序遍历 II 还是由上往下遍历每一次，结束后通过翻转达到由下往上遍历的效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrderBottom(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; que=new ArrayDeque\u0026lt;\u0026gt;(); if(root==null) return res; que.offer(root); while(!que.isEmpty()){ int len=que.size(); List\u0026lt;Integer\u0026gt; tempList=new ArrayList\u0026lt;\u0026gt;(); while(len\u0026gt;0){ TreeNode node=que.poll(); tempList.add(node.val); if(node.left!=null) que.offer(node.left); if(node.right!=null) que.offer(node.right); len--; } res.add(tempList); } Collections.reverse(res); return res; } } 199. 二叉树的右视图 和层序遍历一样，但是只需要存储每层最右边的元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List\u0026lt;Integer\u0026gt; rightSideView(TreeNode root) { List\u0026lt;Integer\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); if(root==null) return res; queue.offer(root); while(!queue.isEmpty()){ int len=queue.size(); while(len\u0026gt;0){ TreeNode node=queue.poll(); if(len==1){ res.add(node.val); } if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); len--; } } return res; } } 637. 二叉树的层平均值 每层的个数len会在while循环里减少，需要用额外的变量来存储个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public List\u0026lt;Double\u0026gt; averageOfLevels(TreeNode root) { List\u0026lt;Double\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); if(root==null) return res; queue.offer(root); while(!queue.isEmpty()){ int len=queue.size(); int nums=len; double sum=0; while(len\u0026gt;0){ TreeNode node=queue.poll(); sum+=node.val; if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); len--; } double average=sum/nums; res.add(average); } return res; } } 429. N 叉树的层序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(Node root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;Node\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); if(root==null) return res; queue.offer(root); while(!queue.isEmpty()){ int len=queue.size(); List\u0026lt;Integer\u0026gt; tempList=new ArrayList\u0026lt;\u0026gt;(); while(len\u0026gt;0){ Node node=queue.poll(); tempList.add(node.val); List\u0026lt;Node\u0026gt; nodeList=node.children; for(int i=0;i\u0026lt;nodeList.size();i++){ queue.offer(nodeList.get(i)); } len--; } res.add(tempList); } return res; } } 515. 在每个树行中找最大值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List\u0026lt;Integer\u0026gt; largestValues(TreeNode root) { List\u0026lt;Integer\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); if(root==null) return res; queue.offer(root); while(!queue.isEmpty()){ int len=queue.size(); int max=Integer.MIN_VALUE; while(len\u0026gt;0){ TreeNode node=queue.poll(); max=Math.max(max,node.val); if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); len--; } res.add(max); } return res; } } 116. 填充每个节点的下一个右侧节点指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public Node connect(Node root) { Queue\u0026lt;Node\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); if(root==null) return root; queue.offer(root); while(!queue.isEmpty()){ int len=queue.size(); List\u0026lt;Node\u0026gt; nodeList=new ArrayList\u0026lt;\u0026gt;(); while(len\u0026gt;0){ Node node=queue.poll(); nodeList.add(node); if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); len--; } for(int i=0;i\u0026lt;nodeList.size();i++){ if(i==nodeList.size()-1){ nodeList.get(i).next=null; break; } nodeList.get(i).next=nodeList.get(i+1); } } return root; } } 104. 二叉树的最大深度 迭代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maxDepth(TreeNode root) { int res=0; Queue\u0026lt;TreeNode\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); if(root==null) return res; queue.offer(root); while(!queue.isEmpty()){ int len=queue.size(); while(len\u0026gt;0){ TreeNode node=queue.poll(); if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); len--; } res++; } return res; } } 递归\n1 2 3 4 5 6 7 8 class Solution { public int maxDepth(TreeNode root) { if(root==null) return 0; int leftDepth=maxDepth(root.left); int rightDepth=maxDepth(root.right); return Math.max(leftDepth,rightDepth)+1; } } 111. 二叉树的最小深度\n迭代\n当遇到某个节点左右孩子都为null时，说明已经有一条完结了的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int minDepth(TreeNode root) { int res=0; Queue\u0026lt;TreeNode\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); if(root==null) return res; queue.offer(root); while(!queue.isEmpty()){ int len=queue.size(); res++; while(len\u0026gt;0){ TreeNode node=queue.poll(); if(node.left==null\u0026amp;\u0026amp;node.right==null) return res; if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); len--; } } return res; } } 递归\n空树处理: 如果 root 为空，返回深度 0。 左子树为空: 如果 root.left 为空，说明最小深度只能从右子树获得，直接返回 minDepth(root.right) + 1。 右子树为空: 如果 root.right 为空，说明最小深度只能从左子树获得，直接返回 minDepth(root.left) + 1。 左右子树都不为空: 如果左右子树都不为空，递归计算左子树和右子树的最小深度，取较小值加 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int minDepth(TreeNode root) { if (root == null) return 0; // 空树深度为 0 // 如果左子树为空，只计算右子树的深度 if (root.left == null) { return minDepth(root.right) + 1; } // 如果右子树为空，只计算左子树的深度 if (root.right == null) { return minDepth(root.left) + 1; } // 如果左右子树都不为空，取较小值加 1 int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); return Math.min(leftDepth, rightDepth) + 1; } } 226. 翻转二叉树 递归\n前序遍历（中左右）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public TreeNode invertTree(TreeNode root) { reverse(root); return root; } private void reverse(TreeNode node) { if (node == null) return; TreeNode temp = node.left; node.left = node.right; node.right = temp; reverse(node.left); reverse(node.right); } } 迭代 深度优先遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public TreeNode invertTree(TreeNode root) { if(root==null) return null; Deque\u0026lt;TreeNode\u0026gt; stack=new ArrayDeque\u0026lt;\u0026gt;(); stack.push(root); while(!stack.isEmpty()){ TreeNode node=stack.pop(); //前序：中左右。放入栈为左右中 if(node!=null){ if(node.left!=null) stack.push(node.left); if(node.right!=null) stack.push(node.right); //做交换操作 TreeNode temp=node.left; node.left=node.right; node.right=temp; } } return root; } } 广度优先遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public TreeNode invertTree(TreeNode root) { if(root==null) return root; Queue\u0026lt;TreeNode\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); while(!queue.isEmpty()){ TreeNode node=queue.poll(); if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); //左交换操作 TreeNode temp=node.left; node.left=node.right; node.right=temp; } return root; } } 101. 对称二叉树 N 递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) return true; return compare(root.left,root.right); } private boolean compare(TreeNode left,TreeNode right){ if(left==null\u0026amp;\u0026amp;right==null) return true; else if(left!=null\u0026amp;\u0026amp;right==null) return false; else if(left==null\u0026amp;\u0026amp;right!=null) return false; else if(left.val!=right.val) return false; else{ boolean out=compare(left.left,right.right); boolean in=compare(left.right,right.left); return out\u0026amp;\u0026amp;in; } } } 迭代\nDeque接口时双端队列，Queue接口是普通队列，没有offerFirst之类的方法\n不管是使用双端队列还是普通队列，取出时的顺序都要为：1.左比上2.右 , 1.右比上2.左\n双端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public boolean isSymmetric(TreeNode root) { if(root==null) return true; Deque\u0026lt;TreeNode\u0026gt; queue=new LinkedList\u0026lt;\u0026gt;(); queue.offerFirst(root.left); queue.offerLast(root.right); while(!queue.isEmpty()){ TreeNode left=queue.pollFirst(); TreeNode right=queue.pollLast(); if(left==null\u0026amp;\u0026amp;right==null) continue; else if(left==null\u0026amp;\u0026amp;right!=null) return false; else if(left!=null\u0026amp;\u0026amp;right==null) return false; else if(left.val!=right.val) return false; //保证出来的顺序为 // 1.左比上2.右 1.右比上2.左 queue.offerFirst(left.left); queue.offerFirst(left.right); queue.offerLast(right.right); queue.offerLast(right.left); } return true; } } 普通\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public boolean isSymmetric(TreeNode root) { if(root==null) return true; Queue\u0026lt;TreeNode\u0026gt; queue=new LinkedList\u0026lt;\u0026gt;(); queue.offer(root.left); queue.offer(root.right); while(!queue.isEmpty()){ TreeNode left=queue.poll(); TreeNode right=queue.poll(); if(left==null\u0026amp;\u0026amp;right==null) continue; else if(left==null\u0026amp;\u0026amp;right!=null) return false; else if(left!=null\u0026amp;\u0026amp;right==null) return false; else if(left.val!=right.val) return false; queue.offer(left.left); queue.offer(right.right); queue.offer(left.right); queue.offer(right.left); } return true; } } 559. N 叉树的最大深度 N 根据二叉树的最大深度得来\n使用递归\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int maxDepth(Node root) { if(root==null) return 0; if(root.children.size()==0) return 1; int max=Integer.MIN_VALUE; for(Node node:root.children){ max=Math.max(max,maxDepth(node)); } return max+1; } } 使用迭代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxDepth(Node root) { Queue\u0026lt;Node\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); int max=0; if(root==null) return 0; if(root.children.size()==0) return 1; queue.offer(root); while(!queue.isEmpty()){ int len=queue.size(); while(len\u0026gt;0){ Node node=queue.poll(); if(node.children.size()!=0){ for(Node temp:node.children){ queue.offer(temp); } } len--; } max++; } return max; } } 222. 完全二叉树的节点个数 迭代法（层序遍历）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int countNodes(TreeNode root) { int counts=0; if(root==null) return counts; Queue\u0026lt;TreeNode\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(root); while(!queue.isEmpty()){ TreeNode node=queue.poll(); counts++; if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); } return counts; } } 递归 N，结合层序遍历的递归法\n最初使用形参int count是错误的，原因：counts 是一个基本数据类型 int，传递给 countHelper 方法时，是按值传递的。所以，countHelper 方法中的 counts 变量改变不会影响到原始的 counts 变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { int counts=0; public int countNodes(TreeNode root) { countHelper(root); return counts; } private void countHelper(TreeNode root){ if(root==null) return; counts++; if(root.left!=null) countHelper(root.left); if(root.right!=null) countHelper(root.right); } } 精简版\n1 2 3 4 5 6 7 8 9 class Solution { // 通用递归解法 public int countNodes(TreeNode root) { if(root == null) { return 0; } return countNodes(root.left) + countNodes(root.right) + 1; } } 110. 平衡二叉树 N 递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean isBalanced(TreeNode root) { return helper(root)!=-1; } private int helper(TreeNode node){ if(node==null) return 0; int left=helper(node.left); if(left==-1) return -1; int right=helper(node.right); if(right==-1) return -1; if(Math.abs(right-left)\u0026lt;=1) return Math.max(left, right) + 1; else return -1; } } 迭代\n回溯 257. 二叉树的所有路径 详细执行流程 假设给定的二叉树如下：\n1 2 3 4 5 1 / \\ 2 3 / \\ 4 5 执行 binaryTreePaths(root) 时，初始 res 为空，path 也为空。\n1. 访问根节点 1 path = [1] 由于 1 不是叶子节点，继续递归遍历左子树。 2. 访问左子节点 2 path = [1, 2] 由于 2 不是叶子节点，继续递归遍历左子树。 3. 访问左子节点 4 path = [1, 2, 4] 4 是叶子节点，将 \u0026quot;1-\u0026gt;2-\u0026gt;4\u0026quot; 存入 res 回溯：返回到 2 之前，撤销 4 的影响 path.remove(path.size() - 1)，变回 path = [1, 2] 4. 访问右子节点 5 path = [1, 2, 5] 5 是叶子节点，将 \u0026quot;1-\u0026gt;2-\u0026gt;5\u0026quot; 存入 res 回溯：返回到 2 之前，撤销 5 的影响 path.remove(path.size() - 1)，变回 path = [1, 2] 5. 回溯到根节点 1 回溯：撤销 2 的影响 path.remove(path.size() - 1)，变回 path = [1] 继续递归遍历右子树。 6. 访问右子节点 3 path = [1, 3] 3 是叶子节点，将 \u0026quot;1-\u0026gt;3\u0026quot; 存入 res 回溯：返回到根节点 1，撤销 3 的影响 path.remove(path.size() - 1)，变回 path = [1] 7. 回溯到初始状态 撤销 1 的影响 path.remove(path.size() - 1)，变回 path = [] 最终结果 路径 res 存储：\n1 [\u0026#34;1-\u0026gt;2-\u0026gt;4\u0026#34;, \u0026#34;1-\u0026gt;2-\u0026gt;5\u0026#34;, \u0026#34;1-\u0026gt;3\u0026#34;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public List\u0026lt;String\u0026gt; binaryTreePaths(TreeNode root) { List\u0026lt;String\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; path=new ArrayList\u0026lt;\u0026gt;(); if(root==null) return res; traversal(res,path,root); return res; } private void traversal(List\u0026lt;String\u0026gt; res,List\u0026lt;Integer\u0026gt; path,TreeNode node){ //中 path.add(node.val); if(node.left==null\u0026amp;\u0026amp;node.right==null){ StringBuilder sb=new StringBuilder(); for(int i=0;i\u0026lt;path.size();i++){ sb.append(path.get(i)); if(i!=path.size()-1){ sb.append(\u0026#34;-\u0026gt;\u0026#34;); } } res.add(sb.toString()); return; } //左 if(node.left!=null){ traversal(res,path,node.left); //回溯 path.remove(path.size()-1); } //右 if(node.right!=null){ traversal(res,path,node.right); //回溯 path.remove(path.size()-1); } } } 方式二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;String\u0026gt; binaryTreePaths(TreeNode root) { deal(root, \u0026#34;\u0026#34;); return result; } public void deal(TreeNode node, String s) { if (node == null) return; if (node.left == null \u0026amp;\u0026amp; node.right == null) { result.add(new StringBuilder(s).append(node.val).toString()); return; } String tmp = new StringBuilder(s).append(node.val).append(\u0026#34;-\u0026gt;\u0026#34;).toString(); deal(node.left, tmp); deal(node.right, tmp); } } 404. 左叶子之和 N 左叶子，不是层序遍历的每一层的最左边的节点，而是某个节点的左子节点，并且这个左子节点是叶子节点（即没有左右子节点）。\n错误示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { int sum=0; public int sumOfLeftLeaves(TreeNode root) { if(root==null) return sum; helper(root,false); return sum; } private void helper(TreeNode node,boolean isLeft){ if(node==null) return; if(node.left==null\u0026amp;\u0026amp;node.right==null\u0026amp;\u0026amp;isLeft) sum+=node.val; if(node.left!=null) helper(node.left,true); if(node.left==null\u0026amp;\u0026amp;node.right!=null) helper(node.right,false); } } 错误原因：\nsum不能当作形参传递，可以作为全局变量，或者使用int[]类型来 左叶子判断错误： 在 if (node.left == null \u0026amp;\u0026amp; node.right == null) 中直接将当前节点视为左叶子，这是不正确的。 只有当前节点是左子节点，并且是叶子节点时，才能累加其值。你需要通过 isLeft 参数来判断当前节点是否是左子节点。 递归调用逻辑错误： 你在 if (node.left == null \u0026amp;\u0026amp; node.right != null) 中递归调用右子树，这是不必要的。 右子树的递归调用不需要条件判断，直接调用即可。 左叶子累加条件不完整： 你需要在当前节点是左叶子时累加其值，而不是对所有叶子节点都累加。 正确代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { int sum=0; public int sumOfLeftLeaves(TreeNode root) { if(root==null) return sum; helper(root,false); return sum; } private void helper(TreeNode node,boolean isLeft){ if(node==null) return; if(node.left==null\u0026amp;\u0026amp;node.right==null\u0026amp;\u0026amp;isLeft) sum+=node.val; helper(node.left,true); helper(node.right,false); } } 回溯 513. 找树左下角的值 层序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findBottomLeftValue(TreeNode root) { Queue\u0026lt;TreeNode\u0026gt; queue=new ArrayDeque\u0026lt;\u0026gt;(); int res=0; queue.offer(root); while(!queue.isEmpty()){ int len=queue.size(); for(int i=0;i\u0026lt;len;i++){ TreeNode node=queue.poll(); if(i==0) res= node.val; if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); } } return res; } } 递归 回溯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { int res; int maxDepth=Integer.MIN_VALUE; public int findBottomLeftValue(TreeNode root) { traversal(0,root); return res; } private void traversal(int depth,TreeNode node){ if(node.left==null\u0026amp;\u0026amp;node.right==null){ if(depth\u0026gt;maxDepth){ maxDepth=depth; res=node.val; } return; } if(node.left!=null){ depth++; traversal(depth,node.left); depth--; } if(node.right!=null){ depth++; traversal(depth,node.right); depth--; } } } ","date":"2025-01-13T22:27:13+08:00","image":"https://suechinrry.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/lst_hu_1525ede3a30447c3.jpg","permalink":"https://suechinrry.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","title":"数据结构与算法"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","permalink":"https://suechinrry.github.io/p/placeholder-text/","title":"Placeholder Text"}]