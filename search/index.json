[{"content":"安装Linux 安装虚拟机 下载：\nhttps://softwareupdate.vmware.com/cds/vmw-desktop/ws/17.6.2/24409262/windows/core/VMware-workstation-17.6.2-24409262.exe.tar\n检查虚拟网卡：\nwin+r 输入 ncpa.cpl，检查有无虚拟网卡VMnet1和VMnet8\n安装Linux centOS7下载：Index of /7.6.1810/isos/x86_64\n新建虚拟机，选择典型 选择文件 设置名称、密码 放到D盘 更改最大磁盘大小为40GB 启动 快照 打开快照管理器 选择一个快照进行跳转 远程连接Linux 通过第三方软件：FinalShell\n下载网址 FinalShell官网\n连接操作 打开vm虚拟机 打开终端，输入ifconfig，获取ip 用finalshell进行连接 建立连接，双击启动 Linux linux的目录结构 /为根路径。 例如： /user/test/hello.txt\n命令和命令行 命令：一个命令就是一个linux程序，没有图形化界面，可以在命令行提供字符化反馈\n命令行：linux终端，是一种命令提示符页面\n命令格式 在 Linux 中，命令的一般格式如下：\n1 command [options] [arguments] command：要执行的命令，比如 ls、cd、cp 等。 options（可选项）：修改命令行为的选项，通常以一个或两个连字符（- 或 --）开头。例如：-l、--help。 arguments（参数，可选项）：命令操作的对象，通常是文件名、目录名或者其他需要命令处理的内容 Home目录和工作目录 Home目录：每个用户通常都会在 /home 目录下有一个以用户名命名的子目录，作为该用户的主目录。 例如：==/home/用户名==\n工作目录：命令行在执行命令时，需要一个工作目录，默认设置工作目录在该用户的home目录\n特殊路径符 . 表示当前目录，例如：cd ./desktop等同于 cd desktop .. 表示上级目录，例如：cd ..就是返回上一级，cd ../..就是返回上两级 ~ 表示home目录，例如：cd ~等同于cd 命令 ls命令 1 ls [-a -l -h] [linux路径] 作用：列出当前目录的内容，默认为home目录\n-a：-all，列出全部文件夹，包括隐藏的文件/文件夹（==文件或文件夹以 . 开头就能自动隐藏==）\n-l：以列表（竖向）展示内容，并且展示更多的信息。包含==权限信息，所属用户，所属用户组==\n-h：可读格式显示文件大小\n==混合使用==：\n例如：同时使用-a和-l\n写法一：-a -l 写法二：-al，-la 目录切换相关命令 cd 1 cd [linux路径] 带参数：切换到指定目录 不带参数：切换到home目录 pwd 1 pwd 查看当前工作目录\n创建目录命令 mkdir创建目录 只有在home目录下才有创建目录的权限\n1 mkdir [-p] [linux路径] 创建新的目录\n不带选项：创建目录时要求父目录必须存在。如果父目录不存在，则会报错。 -p：用于创建多级目录，如果某个中间目录不存在，-p 会自动创建它们，而不会报错。例如： 1 mkdir -p /home/用户名/project/src 如果 /home/user/project/ 和 /home/user/project/src 目录不存在，mkdir -p 会依次创建它们。如果目录已经存在，它也不会报错。\nmkdir 只会创建目录，不会切换到新目录。 在ls -l命令下的==以d开头的是文件夹，以-开头的是文件==。\n文件操作命令 touch新建文件 1 touch [linux路径] 例如：touch test.txt\n查看文件内容 cat 1 cat [linux路径] 例如：cat test.txt\n==直接显示全部内容==\nmore 1 more [linux路径] 例如：more test.txt\n==可以翻页查看文件，空格是翻到下一页，q是退出查看==\ncp复制文件或文件夹 1 cp [-r] 参数1 参数2 -r：复制文件夹时需要添加-r 参数1：是被复制的文件（文件夹） 参数2：是要复制到的地方 mv移动文件或文件夹 1 mv 参数1 参数2 参数1：是被移动的文件（文件夹） 参数2：是要移动到的地方 mv也可以用来重命名文件，例如：mv test1.txt test2.txt，将test1重命名为test2 rm删除文件或文件夹 1 rm [-r -f] 参数1 参数2 ... ... 参数n -r：和cp一样，-r用于操作文件夹 -f：强制删除，强制删除不会有提示。普通用户删除内容不会有提示，root用户删除内容时才有提示。（普通用户一般用不到-f）。 参数1 参数2 \u0026hellip; \u0026hellip; 参数n，参数代表要删除的文件或路径，用空格隔开。 通配符 *\nabc* 表示以abc开头\n*abc * 表示含有abc的\n*abc 表示以abc结尾的\nwhich查找命令所在位置 1 which 要查找的命令 例如：which cd，which cp等\nfind查找文件所在位置 按文件名查找\n1 find 起始路径 -name 文件名 有空格或特殊字符时，打引号，“文件名” 例如，在/路径下查找文件名为aaa的所在位置， find / -name “aaa”\n按文件大小查找\n1 find 起始路径 -size +(或-)n[kMG] +：表示大于 -：表示小于 n：数字n表示文件大小 kMG：k为KB，M为MB，G为GB 例如，要查找大于500KB的文件，find ~ -size +500k\ngrep筛选文件中特定的行 1 grep [-n] 关键字 文件路径 建议关键字打引号，==有空格或特殊字符时==，“关键字” -n：显示匹配模式的行号。 文件路径：==可作为内容输入端口== wc统计文件内容 1 wc [-l -w -c -m] 文件路径 -l：显示行数。 -w：显示单词数。 -c：显示字节数（通常是文件的大小。 -m：显示字符数（与字节数略有不同，主要是对多字节字符集（如 UTF-8）的处理。 不使用任何选项，wc 命令会默认输出 行数、单词数和字节数 三项统计信息。 tail查看文件尾部的内容 1 tail [-f -数字] linux路径 -f：表示持续监视文件的变化，并显示新增的内容。 -数字：不写默认查看后10行。写了，例如，-5即为查看后5行。 切换root用户 su - root ，密码和普通用户的一样 输入exit退出root echo让命令行输出指定内容 1 echo 想要命令行输出的内容 有空格或特殊字符时，建议打引号。\n管道符 | 将左边命令的结果作为右边命令的输入。\n类似于，左边命令的输出（标准输出）会作为==数据源==传递给右边命令的输入（标准输入）\n反引号`` 被包围的内容，会==被当作命令执行==\n重定向符 输出重定向\u0026gt;：将左边命令的结果覆写到符号右边的文件中 追加重定向\u0026gt;\u0026gt;：将左边命令的结果追加写到符号右边的文件中 vim编辑器 vim是vi的加强版本，vim是文本编辑器\n工作模式\n命令模式，输入模式，底线命令模式。\n命令模式\n进入命令模式\n1 vim 文件路径 文件存在，则用于编辑已有文件；若不存在，则编辑新文件。\n进入输入模式\n按 i、a、o 等键进入输入模式，不同字母光标位置不同，进行编辑。\n按 i：在光标当前位置进入输入模式。\n按 I：在当前行的第一个非空字符前进入输入模式。\n按 a：在光标当前位置后进入输入模式（即光标后一个字符开始输入）。\n按 A：在当前行的末尾进入输入模式。\n按 o：在当前行下面新建一行并进入输入模式。\n按 O：在当前行上面新建一行并进入输入模式。\n快捷键操作\n进入底线命令模式\n按 : 键进入底线命令模式\n输入模式\n按esc退出，进入命令模式\n底线命令\n按wq，保存并退出vim\n按q！，强制退出\n用户和权限 普通用户在home目录下，权限不受限。出了home目录只有只读和执行的权限，无修改权限。\nsu切换用户 1 su [-] [用户名] -：带-表示切换用户后加载环境变量。 退出通过exit 普通用户切换到其他用户需要密码，root用户不用 不写用户名，即su -，会切换到root用户 sudo授权 给普通命令授权，临时以root用户身份执行。\n1 sudo 命令 前提：获得sudo认证\n使用root用户，使用visudo命令\n在文件的最后一行添加\n1 用户名 ALL=(ALL)\tNOPASSWD:ALL :wq保存并退出\n用户和用户组 用户组管理 创建用户组\n1 groupadd 用户组名 删除用户组\n1 groupdel 用户组名 用户管理 创建用户\n1 useradd [-g -d] 用户名 -g：-g 用户组名，将用户添加到已存在的用户组中。不带-g，会自动创建同名的用户组并加入 -d：-d home目录，可以自定义home目录。不带则默认为/home/用户名 删除用户\n1 userdel [-r] 用户名 -r：带了就连同home目录一起删除，不带则只删除用户不删除home目录 查看用户所属组\n1 id 用户名 不带用户名则查看自身\n修改用户所属组\n1 usermod -aG 用户组 用户 查询所有用户\n1 getent passwd 查询所有用户组\n1 getent group 权限信息 ls -l展示出的信息中\n![](屏幕截图 2025-01-20 215232.png)\n其中r为读权限，w为写权限，x为执行权限\nchmod修改权限信息 1 chmod [-R] 权限 文件或文件夹 -R：对文件夹的全部内容应用同样操作\n例如：chmod u=rwx,g=rx,o=x test.txt\n其中u为所属用户的权限，g为所属用户组的权限，o为其他用户的权限\n简化写法：\n类似于rwx最小项。- - x表示001，即为1。\n上面示例可简化为：chmod 751 test.txt\nchown改变所属 只适用于root用户\n1 chown [-R] [用户][:用户组] 文件或文件夹 -R：对文件夹的全部内容应用同样操作 快捷键 ctrl+c 强制停止\nctrl+d 退出\n不能用于退出vi或者vim\nhistory 查看历史命令\n!内容自动匹配并执行历史记录中最近的一条\nctrl+r 输入内容去匹配历史命令。回车后可直接执行这条历史命令；按左or右键得到该命令\nctrl+l 清屏，等同于clear命令\n软件安装 yum命令安装软件 ","date":"2025-01-15T00:00:00Z","permalink":"https://suechinrry.github.io/p/linux/","title":"Linux"},{"content":"Redis简介 Redis 是一个基于键值对（Key-Value）的 NoSQL 数据库，属于非关系型数据库。\n官网：\n中文：https://www.redis.com.cn/documentation.html\n英文：Redis - The Real-time Data Platform\n参考命令：http://doc.redisfans.com/\n下载 redis/redis-hashes: Redis tarball SHA1 hashes\n","date":"2025-01-15T00:00:00Z","permalink":"https://suechinrry.github.io/p/redis/","title":"Redis"},{"content":"数组 数组是存放在连续内存空间上的相同类型数据的集合。\n下标从0开始 内存空间的地址是连续的 数组的元素不能删除只能覆盖 二分法 使用前提：有序数组，无重复元素\n二分法\nleft，right，middle只根据条件来改变left或right的值，middle的值自然会改变\n写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。\n两种写法的区别while循环条件不同，r的赋值不同\n写法1：[left, right]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int search(int[] nums, int target) { int l=0; int r=nums.length-1; int mid=0; while(l\u0026lt;=r){ mid= l + ((r - l) / 2); if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid-1; } else{ return mid; } } return -1; } } 将mid=（l+r）/2换成mid= l + ((r - l) / 2)的原因:当l和r都很大时，会导致溢出。\n写法2：[left,right)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int search(int[] nums, int target) { int l=0; int r=nums.length; int mid=0; while(l\u0026lt;r){ mid=l+(r-l)/2; if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid; } else{ return mid; } } return -1; } } 相关题目 35.搜索插入位置 N 暴力解法\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public int searchInsert(int[] nums, int target) { for(int i=0;i\u0026lt;nums.length;i++){ // 一旦发现大于或者等于target的num[i]，那么i就是我们要的结果 if(nums[i]\u0026gt;=target){ return i; } } return nums.length; } } 二分查找\n写法1：[l,r]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int searchInsert(int[] nums, int target) { int l=0; int r=nums.length-1; int mid=0; while(l\u0026lt;=r){ mid=l+(r-l)/2; if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid-1; } else{ return mid; } } //数组中未找到target元素 //target在数组所有元素之后，[left, right]是右闭区间，需要返回 right +1 return r+1; } } r 指针已经指向了数组中小于 target 的最后一个元素的位置\n34.在排序数组中查找元素的第一个和最后一个位置 含有重复元素时\n用两个二分法来查找左右边界\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int[] searchRange(int[] nums, int target) { int[] answer = new int[]{-1, -1}; int l = 0; int r = nums.length - 1; int mid = 0; int leftBorder = -1; int rightBorder = -1; // 查找左边界 while (l \u0026lt;= r) { mid = l + (r - l) / 2; if (nums[mid] \u0026gt;= target) { r = mid - 1; leftBorder = mid; // 更新左边界 } else { l = mid + 1; } } // 查找右边界 l = 0; r = nums.length - 1; while (l \u0026lt;= r) { mid = l + (r - l) / 2; if (nums[mid] \u0026lt;= target) { l = mid + 1; rightBorder = mid; // 更新右边界 } else { r = mid - 1; } } // 情况一：目标值不存在 if (leftBorder == -1 || rightBorder == -1 || nums[leftBorder] != target) { return new int[]{-1, -1}; } // 返回目标值的开始位置和结束位置 return new int[]{leftBorder, rightBorder}; } } 查找左边界的核心目标\n我们需要找到目标值在数组中最早出现的位置。在二分查找的过程中，r 和 l 指针会根据当前查找的值是否符合目标来不断调整。关键的思想是通过“收缩查找范围”来逼近目标值的左边界。\n为什么使用 r 来确定左边界？\n当 nums[mid] \u0026gt;= target 时，我们可以确定目标值可能在当前位置 mid 或 mid 左侧的区间。 为什么是左侧？ 因为我们正在寻找左边界，而且数组是非递减顺序排列的。如果当前 nums[mid] 大于或等于目标值，目标值可能出现在 mid 或它的左边。 例如，如果目标值是 8，在 [5, 7, 7, 8, 8, 10] 这样的数组中，8 出现了两次。你需要确定目标值第一个出现的位置。即便在 mid 处找到了 8，我们还需要继续查找 mid 左侧，看看是否存在更早的 8。 收缩右边界 r = mid - 1，这样我们就会继续在 mid 左边的区间进行查找。因为目标值可能出现在 mid 或它的左侧。 更新 leftBorder = r： 当 nums[mid] \u0026gt;= target 时，目标值在 mid 或它的左边，所以我们更新 r 位置为左边界的位置（r 逐步逼近目标值的左侧）。 这时，leftBorder 记录的其实是当前 mid 左侧的一个边界，而不是 mid 本身。因为如果 nums[mid] \u0026gt;= target，说明目标值应该在 mid 或左边，所以我们更新左边界为 r，以便后续判断是否存在更小的值。 leftBorder == -1\nleftBorder 用来记录目标值在数组中最左边的出现位置。如果 leftBorder 为 -1，意味着在查找左边界的过程中没有找到目标值。也就是说，目标值在数组中不存在，所以此时应该返回 [-1, -1]，表示目标值不存在。\n为什么是 -1？ 在查找过程中，leftBorder 的初始值是 -1，只有当查找到目标值时才会更新 leftBorder。如果最终没有找到目标值，leftBorder 仍然保持为 -1。 nums[leftBorder] != target\n这一部分检查在找到的 leftBorder 位置是否真的等于目标值 target。也就是说，即使 leftBorder 不等于 -1，我们还需要确认 nums[leftBorder] 这个位置的值是否确实是目标值 target。\n为什么要做这个检查？ 可能出现一种情况：假设目标值并未出现在数组中，但二分查找的过程可能仍然会更新 leftBorder 为某个位置。为了确保 leftBorder 位置的值确实是目标值，我们需要进行额外的检查。只有当 nums[leftBorder] == target 时，才说明 leftBorder 是有效的目标值出现位置。 组合解释：\n如果 leftBorder == -1，表示目标值在数组中不存在，所以直接返回 [-1, -1]。 如果 rightBorder == -1，同样表示目标值在数组中不存在，所以也返回 [-1, -1]。 如果 nums[leftBorder] != target，说明 leftBorder 虽然不是 -1，但是找到了一个错误的位置，或者在 leftBorder 位置并没有找到目标值。因此，也应该返回 [-1, -1]。 为什么是 leftBorder = mid 而不是 leftBorder = r？\n查找左边界的目标是找到 目标值第一次出现的位置。在二分查找的过程中，当 nums[mid] \u0026gt;= target 时，说明目标值可能在 mid 或它的左边，所以我们需要继续往左侧查找，并且 mid 是可能的左边界。\n如果 nums[mid] \u0026gt;= target，说明目标值可能在 mid 位置或其左边\n：\n为什么mid 是可能的左边界？ 假设数组是 [5, 7, 7, 8, 8, 10]，我们要查找目标值 8。 当我们在 mid = 3 时，发现 nums[mid] == 8，这时我们知道 8 出现在 mid 位置或者它左边的位置。 因为我们要找到 第一次出现的位置，即最左边的目标值，所以即使在 mid 处找到了目标值，我们仍然需要继续向左查找。 69.x 的平方根 N 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int mySqrt(int x) { if (x == 0) return 0; int l=1; int r=x; int mid=0; while(l\u0026lt;=r){ mid=l+(r-l)/2; if(x/mid\u0026lt;mid){ r=mid-1; } else if(x/mid\u0026gt;mid){ l=mid+1; } else{ return mid; } } return r; } } 为了防止溢出，将mid*mid\u0026gt;x换位x/mid\u0026lt;mid 二分查找最终会使得 l \u0026gt; r，此时区间 [l, r] 会被缩小到一个无法继续分割的状态。此时，r 就是比 sqrt(x) 小的最大整数。 367.有效的完全平方数 移除元素 移除元素 N\n暴力解法，两层for循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int removeElement(int[] nums, int val) { int n=nums.length; for(int i=0;i\u0026lt;n;i++){ if(nums[i]==val){ for(int j=i+1;j\u0026lt;n;j++){ nums[j-1]=nums[j]; } n--;//长度减一 i--;//下一次还是得从现在这个位置开始。 } } return n; } } 双指针\nfast遍历整个数组，slow用来指向更新新数组下标的位置。\n其实count没必要\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int removeElement(int[] nums, int val) { int slow=0; int count=0; for(int fast=0;fast\u0026lt;nums.length;fast++){ if(nums[fast]!=val){//不是目标数就进行更新，将下标为fast的值更新到下标slow nums[slow]=nums[fast]; slow++; count++; } //与目标值相等就不做处理，等待被覆盖 } return count; } } 相关题目 26.删除排序数组中的重复项 N 第一个元素不用处理，从第二个元素开始。所以slow的初始值是1，fast的初始值也为1，而且为了避免下标溢出，将nums[fast]!=nums[fast+1]换成nums[fast]!=nums[fast-1]。\nslow 指针始终指向下一个应该放置去重后元素的位置。每当我们遇到一个不重复的元素时，我们就将其放入 nums[slow] 位置，并且增加 slow 的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int slow=1; for(int fast=1;fast\u0026lt;nums.length;fast++){ if(nums[fast]!=nums[fast-1]){ nums[slow]=nums[fast]; slow++; } } return slow; } } 283.移动零 844.比较含退格的字符串 ==对于数组，直接使用 length，不加括号。==\n==对于字符串，使用 length() 方法，记得加括号。==\nStringBuilder 和 StringBuffer 可变的字符串类\n如果你只在单线程环境中操作字符串，使用 StringBuilder 更好，因为它性能更优。 如果你需要在多线程环境中操作同一个字符串对象，使用 StringBuffer，它提供了线程安全保证，但性能可能稍逊色。 以下类和接口可以用作栈：\nStack（传统栈类） Deque（推荐，使用 ArrayDeque 或 LinkedList 实现） LinkedList（兼容双端队列和栈） 自定义栈（数组或链表实现） 线程安全的栈（如 Collections.synchronizedDeque 包装的 Deque） 优先推荐使用 Deque 接口（如 ==ArrayDeque==），因为它性能更高且设计更现代化。\n栈相关方法：\nArrayDeque 实现了 Deque 接口，支持以下与栈相关的方法：\npush(E e)\n将元素压入栈（队列的头部）。 等同于 addFirst()。 时间复杂度：O(1)。 1 2 3 ArrayDeque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push(1); // 入栈 stack.push(2); // 入栈 pop()\n移除并返回栈顶元素（队列的头部元素）。 等同于 removeFirst()。 如果栈为空，调用此方法会抛出 NoSuchElementException。 时间复杂度：O(1)。 1 int element = stack.pop(); // 出栈，输出 2 peek()\n返回栈顶元素，但不移除它（查看队列的头部元素）。 等同于 peekFirst()。 如果栈为空，返回 null。 时间复杂度：O(1)。 1 int top = stack.peek(); // 查看栈顶元素，输出 1 isEmpty()\n判断栈是否为空。 时间复杂度：O(1)。 1 boolean isEmpty = stack.isEmpty(); // 判断栈是否为空 size()\n返回栈的元素个数。 时间复杂度：O(1)。 1 int size = stack.size(); // 返回栈的大小 977.有序数组的平方 N 暴力\n1 2 3 4 5 6 7 8 9 class Solution { public int[] sortedSquares(int[] nums) { for(int i=0;i\u0026lt;nums.length;i++){ nums[i]=nums[i]*nums[i]; } Arrays.sort(nums); return nums; } } 双指针排序\n左边从0开始，右边从length-1开始。\n因为数组是按照非递减排列的，所以说右边的数大于等于左边。\n==这道题求的是平方大的。==\nnums[left]与nusm[right]相加。大于0，则说明right下标的数要大些；小于0，就说明left下标的绝对值要大些\n==这个比较相加大于0小于0代替比较两个数的平方的大小。==\n比较完后，将得到的结构写道新的数组里，而且还要移动左或者右指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int[] sortedSquares(int[] nums) { int left=0; int right=nums.length-1; int[] answer=new int[nums.length]; int i=nums.length-1; while(left\u0026lt;=right){ if(nums[left]+nums[right]\u0026lt;0){ answer[i]=nums[left]*nums[left]; left++; } else{ answer[i]=nums[right]*nums[right]; right--; } i--; } return answer; } } 若仅仅按照大小排列则为以下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int[] sortedArray(int[] nums) { int left = 0; // 左指针 int right = nums.length - 1; // 右指针 int[] answer = new int[nums.length]; // 用于存储结果 int i = 0; // 从结果数组的开头开始填充 while (left \u0026lt;= right) { if (nums[left] \u0026lt;= nums[right]) { answer[i] = nums[left]; left++; } else { answer[i] = nums[right]; right--; } i++; } return answer; } } 长度最小的子数组 长度最小的子数组 滑动窗口（双指针）\n相关题目 ","date":"2025-01-13T22:27:13+08:00","image":"https://suechinrry.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/lst_hu16098936575455658780.jpg","permalink":"https://suechinrry.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","title":"数据结构与算法"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","permalink":"https://suechinrry.github.io/p/placeholder-text/","title":"Placeholder Text"}]