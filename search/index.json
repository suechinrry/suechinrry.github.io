[{"content":"Linux 安装Linux 安装虚拟机 下载：\nhttps://softwareupdate.vmware.com/cds/vmw-desktop/ws/17.6.2/24409262/windows/core/VMware-workstation-17.6.2-24409262.exe.tar\n检查虚拟网卡：\nwin+r 输入 ncpa.cpl，检查有无虚拟网卡VMnet1和VMnet8\n安装Linux centOS7下载：Index of /7.6.1810/isos/x86_64\n新建虚拟机，选择典型 选择文件 设置名称、密码 放到D盘 更改最大磁盘大小为40GB 启动 快照 打开快照管理器 选择一个快照进行跳转 远程连接Linux 通过第三方软件：FinalShell\n下载网址 FinalShell官网\n连接操作 打开vm虚拟机 打开终端，输入ifconfig，获取ip 用finalshell进行连接 建立连接，双击启动 Linux相关 linux的目录结构 /为根路径。 例如： /user/test/hello.txt\n命令和命令行 命令：一个命令就是一个linux程序，没有图形化界面，可以在命令行提供字符化反馈\n命令行：linux终端，是一种命令提示符页面\n命令格式 在 Linux 中，命令的一般格式如下：\n1 command [options] [arguments] command：要执行的命令，比如 ls、cd、cp 等。 options（可选项）：修改命令行为的选项，通常以一个或两个连字符（- 或 --）开头。例如：-l、--help。 arguments（参数，可选项）：命令操作的对象，通常是文件名、目录名或者其他需要命令处理的内容 Home目录和工作目录 Home目录：每个用户通常都会在 /home 目录下有一个以用户名命名的子目录，作为该用户的主目录。 例如：==/home/用户名==\n工作目录：命令行在执行命令时，需要一个工作目录，默认设置工作目录在该用户的home目录\n特殊路径符 . 表示当前目录，例如：cd ./desktop等同于 cd desktop .. 表示上级目录，例如：cd ..就是返回上一级，cd ../..就是返回上两级 ~ 表示home目录，例如：cd ~等同于cd 命令 ls命令 1 ls [-a -l -h] [linux路径] 作用：列出当前目录的内容，默认为home目录\n-a：-all，列出全部文件夹，包括隐藏的文件/文件夹（==文件或文件夹以 . 开头就能自动隐藏==）\n-l：以列表（竖向）展示内容，并且展示更多的信息。包含==权限信息，所属用户，所属用户组==\n-h：可读格式显示文件大小\n==混合使用==：\n例如：同时使用-a和-l\n写法一：-a -l 写法二：-al，-la 目录切换相关命令 cd 1 cd [linux路径] 带参数：切换到指定目录 不带参数：切换到home目录 pwd 1 pwd 查看当前工作目录\n创建目录命令 mkdir创建目录 只有在home目录下才有创建目录的权限\n1 mkdir [-p] [linux路径] 创建新的目录\n不带选项：创建目录时要求父目录必须存在。如果父目录不存在，则会报错。 -p：用于创建多级目录，如果某个中间目录不存在，-p 会自动创建它们，而不会报错。例如： 1 mkdir -p /home/用户名/project/src 如果 /home/user/project/ 和 /home/user/project/src 目录不存在，mkdir -p 会依次创建它们。如果目录已经存在，它也不会报错。\nmkdir 只会创建目录，不会切换到新目录。 在ls -l命令下的==以d开头的是文件夹，以-开头的是文件==。\n文件操作命令 touch新建文件 1 touch [linux路径] 例如：touch test.txt\n查看文件内容 cat 1 cat [linux路径] 例如：cat test.txt\n==直接显示全部内容==\nmore 1 more [linux路径] 例如：more test.txt\n==可以翻页查看文件，空格是翻到下一页，q是退出查看==\ncp复制文件或文件夹 1 cp [-r] 参数1 参数2 -r：复制文件夹时需要添加-r 参数1：是被复制的文件（文件夹） 参数2：是要复制到的地方 mv移动文件或文件夹 1 mv 参数1 参数2 参数1：是被移动的文件（文件夹） 参数2：是要移动到的地方 mv也可以用来重命名文件，例如：mv test1.txt test2.txt，将test1重命名为test2 rm删除文件或文件夹 1 rm [-r -f] 参数1 参数2 ... ... 参数n -r：和cp一样，-r用于操作文件夹 -f：强制删除，强制删除不会有提示。普通用户删除内容不会有提示，root用户删除内容时才有提示。（普通用户一般用不到-f）。 参数1 参数2 \u0026hellip; \u0026hellip; 参数n，参数代表要删除的文件或路径，用空格隔开。 通配符 *\nabc* 表示以abc开头\n*abc * 表示含有abc的\n*abc 表示以abc结尾的\nwhich查找命令所在位置 1 which 要查找的命令 例如：which cd，which cp等\nfind查找文件所在位置 按文件名查找\n1 find 起始路径 -name 文件名 有空格或特殊字符时，打引号，“文件名” 例如，在/路径下查找文件名为aaa的所在位置， find / -name “aaa”\n按文件大小查找\n1 find 起始路径 -size +(或-)n[kMG] +：表示大于 -：表示小于 n：数字n表示文件大小 kMG：k为KB，M为MB，G为GB 例如，要查找大于500KB的文件，find ~ -size +500k\ngrep筛选文件中特定的行 1 grep [-n] 关键字 文件路径 建议关键字打引号，==有空格或特殊字符时==，“关键字” -n：显示匹配模式的行号。 文件路径：==可作为内容输入端口== wc统计文件内容 1 wc [-l -w -c -m] 文件路径 -l：显示行数。 -w：显示单词数。 -c：显示字节数（通常是文件的大小。 -m：显示字符数（与字节数略有不同，主要是对多字节字符集（如 UTF-8）的处理。 不使用任何选项，wc 命令会默认输出 行数、单词数和字节数 三项统计信息。 tail查看文件尾部的内容 1 tail [-f -数字] linux路径 -f：表示持续监视文件的变化，并显示新增的内容。 -数字：不写默认查看后10行。写了，例如，-5即为查看后5行。 切换root用户 su - root ，密码和普通用户的一样 输入exit退出root echo让命令行输出指定内容 1 echo 想要命令行输出的内容 有空格或特殊字符时，建议打引号。\n管道符 | 将左边命令的结果作为右边命令的输入。\n类似于，左边命令的输出（标准输出）会作为==数据源==传递给右边命令的输入（标准输入）\n反引号`` 被包围的内容，会==被当作命令执行==\n重定向符 输出重定向\u0026gt;：将左边命令的结果覆写到符号右边的文件中 追加重定向\u0026gt;\u0026gt;：将左边命令的结果追加写到符号右边的文件中 vim编辑器 vim是vi的加强版本，vim是文本编辑器\n工作模式\n命令模式，输入模式，底线命令模式。\n命令模式\n进入命令模式\n1 vim 文件路径 文件存在，则用于编辑已有文件；若不存在，则编辑新文件。\n进入输入模式\n按 i、a、o 等键进入输入模式，不同字母光标位置不同，进行编辑。\n按 i：在光标当前位置进入输入模式。\n按 I：在当前行的第一个非空字符前进入输入模式。\n按 a：在光标当前位置后进入输入模式（即光标后一个字符开始输入）。\n按 A：在当前行的末尾进入输入模式。\n按 o：在当前行下面新建一行并进入输入模式。\n按 O：在当前行上面新建一行并进入输入模式。\n快捷键操作\n进入底线命令模式\n按 : 键进入底线命令模式\n输入模式\n按esc退出，进入命令模式\n底线命令\n按wq，保存并退出vim\n按q！，强制退出\n用户和权限 普通用户在home目录下，权限不受限。出了home目录只有只读和执行的权限，无修改权限。\nsu切换用户 1 su [-] [用户名] -：带-表示切换用户后加载环境变量。 退出通过exit 普通用户切换到其他用户需要密码，root用户不用 不写用户名，即su -，会切换到root用户 sudo授权 给普通命令授权，临时以root用户身份执行。\n1 sudo 命令 前提：获得sudo认证\n使用root用户，使用visudo命令\n在文件的最后一行添加\n1 用户名 ALL=(ALL)\tNOPASSWD:ALL :wq保存并退出\n用户和用户组 用户组管理 创建用户组\n1 groupadd 用户组名 删除用户组\n1 groupdel 用户组名 用户管理 创建用户\n1 useradd [-g -d] 用户名 -g：-g 用户组名，将用户添加到已存在的用户组中。不带-g，会自动创建同名的用户组并加入 -d：-d home目录，可以自定义home目录。不带则默认为/home/用户名 删除用户\n1 userdel [-r] 用户名 -r：带了就连同home目录一起删除，不带则只删除用户不删除home目录 查看用户所属组\n1 id 用户名 不带用户名则查看自身\n修改用户所属组\n1 usermod -aG 用户组 用户 查询所有用户\n1 getent passwd 查询所有用户组\n1 getent group 权限信息 ls -l展示出的信息中\n![](屏幕截图 2025-01-20 215232.png)\n其中r为读权限，w为写权限，x为执行权限\nchmod修改权限信息 1 chmod [-R] 权限 文件或文件夹 -R：对文件夹的全部内容应用同样操作\n例如：chmod u=rwx,g=rx,o=x test.txt\n其中u为所属用户的权限，g为所属用户组的权限，o为其他用户的权限\n简化写法：\n类似于rwx最小项。- - x表示001，即为1。\n上面示例可简化为：chmod 751 test.txt\nchown改变所属 只适用于root用户\n1 chown [-R] [用户][:用户组] 文件或文件夹 -R：对文件夹的全部内容应用同样操作 快捷键 ctrl+c 强制停止\nctrl+d 退出\n不能用于退出vi或者vim\nhistory 查看历史命令\n!内容自动匹配并执行历史记录中最近的一条\nctrl+r 输入内容去匹配历史命令。回车后可直接执行这条历史命令；按左or右键得到该命令\nctrl+l 清屏，等同于clear命令\n软件安装 yum命令安装软件 使用报错\n先检查是不是网络连接的问题\n若不是，则（以下操作均需要root权限）\n下载阿里云的镜像源配置文件\n1 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 清理旧缓存\n1 yum makecache PackageKit 服务占用了 Yum 的锁\n暂停并终止 PackageKit 服务\n1 systemctl stop packagekit 禁用 PackageKit 服务\n1 systemctl disable packagekit rpm是linux的安装包格式\n1 yum [-y] [install | remove | search] 软件名称 -y：自动安装，无需手动确认安装或卸载 yum命令==需要root权限或sudo提权== systemctl命令控制软件的关闭和启动 1 systemctl [start | stop | restart | reload | status | enable | disable] 服务名称 start：启动某个服务。\nstop：停止某个服务。\nrestart：重启某个服务。\nreload：重新加载某个服务的配置，不重启服务。\nstatus：查看某个服务的当前状态。\nenable：设置服务开机启动。\ndisable：禁用服务的开机启动。\nsystemctl 不仅可以控制系统内置的服务，还可以控制一些第三方软件和服务，只要这些软件或服务已经通过 systemd 配置为服务单位（unit）。没有注册可以通过手动注册来实现控制\nln命令创建软连接 **软连接：**将文件或文件夹链接到其他位置，==类似于windows的快捷方式==\n1 ln -s 参数1 参数2 参数1：要链接的文件或文件夹 参数1：要链接去的地方 日期和时区 date命令查看时间 好的！按照类似的格式，date 命令的说明如下：\ndate 命令用法 date 命令用于显示和设置系统的日期和时间。\n1 date [-d] [+格式化字符串] -d：显示指定日期的时间，可以用于计算日期（如计算未来或过去的日期）。 ntp命令进行时间同步和校准 安装ntpyum -y install ntp 设置开机自启动systemctl enable ntpd 手动校准，需要root权限ntpdate -u ntp.aliyun.com ip地址和主机名 查询ip 1 ifconfig 主机名 查看主机名 1 hostname 修改主机名\n1 hostnamectl set-hostname 新主机名 域名解析 先查看本机记录。/etc/hosts 在联网去DNS服务器 虚拟机配置固定ip 虚拟机中配置ip地址的网关和网段（ip地址的范围）\n![](屏幕截图 2025-01-24 165409.png)\n![](屏幕截图 2025-01-24 165812.png)\n![](屏幕截图 2025-01-24 165945.png)\n手动修改配置文件，固定ip\n网卡配置文件/etc/sysconfig/network-scripts/ifcfg-ens33\n使用vim对其进行编辑\n修改第四行\ndhcp是自动获取ip，将dhcp换为static\n新增四行内容\n网络传输 ping检查指定的网络服务器是否为可联通状态 1 ping [-c num] ip或主机名 -c num：检查的次数，不写则无限次数持续检查 wget非交互式文件下载器 1 wget [-b] url -b:后台下载，将日志写到工作目录下的wget-log文件下 url：下载链接 curl命令用于发送http网络请求 用于下载文件、获取信息\n1 curl [-O] url -O：用于下载文件，当url是下载链接时保存文件 url：要发起请求的网络地址 端口 通过端口可以锁定计算机的具体程序\nLinux 系统中，端口是标识网络服务的通信通道，共有 65535 个端口号可供使用\n0 - 1023：知名端口（Well-known Ports），由 IANA（Internet Assigned Numbers Authority）分配，用于重要的服务和应用，例如 HTTP（80）、HTTPS（443）、SSH（22）、FTP（21）等。\n1024 - 49151：注册端口（Registered Ports），这些端口号是为某些应用程序、服务和进程保留的，但不如知名端口那样严格，通常由开发者或组织申请使用。通常可以随意使用\n49152 - 65535：动态端口（Dynamic or Private Ports），这些端口通常用于客户端的临时端口，如在建立连接时操作系统会自动分配这些端口。\nnmap命令查看端口占用 先下载nmap\n查看占用情况\n1 nmap 要查看的ip地址 netstat命令查看指定端口的占用情况 需要先下载\n1 yum -y install net-tools 使用\n1 netstat -anp | grep 端口号 格式正确的情况下没返回说明端口没有被使用：指定的端口号当前没有进程在监听。\n进程管理 为管理运行的程序，每个运行的程序都会被操作系统注册为系统中的一个进程。并为每个进程分配一个独有的进程id。\nps命令查看进程信息 1 ps [-e -f] -e：展示全部进程 -f：以完全格式化的形式展示信息（展示全部信息） 一般合起来用ps -ef 可以通过管道符|和grep来进行过滤，例如查找tail命令ps -ef | grep tail\nkill关闭进程 1 kill [-9] 进程id -9：强制关闭 监控主机状态 top查看资源占用 类似与windows任务管理器，默认每隔5秒刷新一次\n1 top ![](屏幕截图 2025-01-25 141245.png)\n基本选项\n-d \u0026lt;时间间隔\u0026gt;：设置刷新间隔（单位为秒）。默认值通常为 3 秒，例如 top -d 2 表示每 2 秒刷新一次。 -n \u0026lt;次数\u0026gt;：指定刷新次数后退出。例如，top -n 5 表示刷新 5 次后退出。 -b：以批处理模式运行，输出结果适合重定向到文件。例如，top -b -n 1 \u0026gt; output.txt 将当前信息保存到 output.txt。 -p \u0026lt;PID\u0026gt;：仅显示指定 PID 的进程信息。例如，top -p 1234 只监控进程号为 1234 的进程。 -u \u0026lt;用户名\u0026gt;：仅显示指定用户的进程。例如，top -u root。 -U \u0026lt;用户ID\u0026gt;：与 -u 类似，但通过用户 ID 过滤。 -H：显示线程级别的信息。 -o \u0026lt;字段\u0026gt;：按指定字段排序。例如，top -o %CPU 按 CPU 使用率排序。 运行时交互键\n当运行 top 后，可以通过以下键盘操作动态调整显示内容：\n排序相关 P：按 CPU 使用率排序（默认）。 M：按内存使用量排序。 T：按进程运行时间排序。 筛选相关 u：筛选特定用户的进程。 k：终止指定 PID 的进程。 显示相关 z：切换颜色显示。 x：高亮排序列。 c：切换显示完整命令行或仅显示进程名称。 f：调整显示字段。 h：显示帮助信息。 q：退出 top。 df命令查看硬盘的使用情况 1 df [-h] -h：单位显示 iostat命令查看cpu和磁盘信息 1 iostat [-x] [参数1] [参数2] -x：显示更多信息 参数1：数字，表示刷新间隔（秒） 参数2：数字，表示刷新几次，不写则一直刷新 sar查看网络的相关统计 由于十分复杂\n常用的写法\n1 sar -n DEV num1 num2 -n：查看网络 DEV：查看网络接口 num1：数字，表示刷新间隔（秒） num2：数字，表示刷新几次，不写则一直刷新 环境变量 环境变量是一种在操作系统中用于存储配置信息的键值对，方便系统和应用程序获取公共参数。它们像全局变量一样，可以影响系统或程序的运行环境。\nenv命令查看当前系统的环境变量 1 env $符号 通过$用环境变量的key去获取值\n例如，\n1 echo $PATH 临时\n1 export 变量名=变量值 永久\n针对当前用户：在~/bashrc文件中 针对所有用户：在/etc/profile文件中 在配置文件里写入export 变量名=变量值 立即生效使用source 配置文件名称 上传和下载 可以鼠标推拽 通过命令 安装lrzsz rz上传，window上传过来 sz下载 压缩和解压 tar和gzip更为常用\n.tar\n定义： .tar 是一种打包格式，用于将多个文件和目录合并成一个文件，方便归档和传输。 特点 仅打包文件和目录，不会压缩数据。 文件大小保持不变。 通常用于备份和归档。 .gz\n定义： .gz 是一种压缩格式，基于 Gzip（GNU zip）压缩算法，用于减少文件大小。 特点 只能压缩单个文件。 不具备打包功能。 常用于网络传输或磁盘存储优化。 .tar.gz\n定义： .tar.gz 是 .tar 和 .gz 的组合，先将文件和目录打包成 .tar 文件，再对 .tar 文件进行 Gzip 压缩。 特点 兼具打包和压缩功能。 是 Linux 系统中最常见的压缩包格式。 tar命令压缩或解压tar和gzip文件 1 tar [-z -c -x -C -v -f] 参数1 参数2 ... ... 参数n -z：不管是解压还是压缩，都使用gzip算法。不写则使用tarball算法，要使用的话一般放在第一个 -c：创建压缩文件，用于压缩模式 -x：解压模式 -C：用于解压模式，选择解压目的地 -v：查看进度。用于显示压缩、解压过程 -f：指定打包或解压的文件名（如 archive.tar）。必须放在所有选项的最后一个 常用组合 压缩 -cvf 将若干文件压缩到某个.tar文件\n例如，将1.txt和2.txt压缩到test.tar中\n1 tar -cvf test.tar 1.txt 2.txt 该命令会将当前目录下的 1.txt 和 2.txt 文件打包到一个名为 test.tar 的归档文件中。\n打包完成后，1.txt 和 2.txt 原文件依然保留，它们的副本被存储在 test.tar 中。\n-zcvf\n先将 1.txt 和 2.txt 文件打包为一个 test.tar 文件，然后用 gzip 压缩生成最终的 test.tar.gz 文件。\n1 tar -zcvf test.tar 1.txt 2.txt 解压 -xvf 解压到当前目录。\n1 tar -xvf test.tar -xvf 解压到指定目录。\n1 tar -xvf test.tar -C /home/jieya -zxvf 解压到指定目录。\n1 tar -zxvf test.tar.gz -C /home/jieya zip、unzip命令压缩或解压zip文件 zip命令压缩文件 1 zip [-r] 参数1 参数2 ... ... 参数n -r：压缩内容含有文件夹要使用-r\n例如，将a.txt和b.txt压缩到test.zip里\n1 zip -r test.zip a.txt b.txt unzip解压 1 unzip [-d] zip压缩包文件 -d：同上面tar命令的-C类似，指定解压目录\n解压到当前目录\n例如，unzip test.zip\n解压到指定目录\n例如，unzip test.zip -d /home/jieya\n目录不存在，unzip 会报错，提示目标目录不存在。有同名文件会覆盖\n","date":"2025-01-15T00:00:00Z","permalink":"https://suechinrry.github.io/p/linux/","title":"Linux"},{"content":"Linux的相关知识 Redis简介 Redis 是一个基于键值对（Key-Value）的 NoSQL 数据库，属于非关系型数据库。\n官网：\n中文：https://www.redis.com.cn/documentation.html\n英文：Redis - The Real-time Data Platform\n参考命令：http://doc.redisfans.com/\n下载 下载文件 redis/redis-hashes: Redis tarball SHA1 hashes\n下载依赖 1 yum -y install gcc tcl 上传文件 需要root用户，是finalshell用root用户连接\n并放到/usr/local/src\n解压文件 1 tar -zxvf redis-7.4.2.tar.gz 进入目录 1 cd redis-7.4.2 运行编译命令 1 make \u0026amp;\u0026amp; make install 安装完成后，默认安装在/usr/local/bin下\n启动 直接启动redis-server 指定配置启动 安装目录下的配置文件 /usr/local/src/redis-7.4.2的redis.conf\n先备份cp redis.conf redis.conf.bck\n修改\nbind 127.0.0.1改为bind 0.0.0.0 daemonize yes requirepass 改为 require * * * * 开机自启动 我们也可以通过配置来实现开机自启。\n首先，新建一个系统服务文件：\n1 vi /etc/systemd/system/redis.service 内容如下：\n1 2 3 4 5 6 7 8 9 10 11 [Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-7.4.2/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target 然后重载系统服务：\n1 systemctl daemon-reload 现在，我们可以用下面这组命令来操作redis了：\n1 2 3 4 5 6 7 8 # 启动 systemctl start redis # 停止 systemctl stop redis # 重启 systemctl restart redis # 查看状态 systemctl status redis 执行下面的命令，可以让redis开机自启：\n1 systemctl enable redis redis命令行客户端 redis-cli\n1 redis-cli [option] [commands] 常见option\n-h 127.0.0.1 要连接redis的ip，默认是127.0.0.1 -p 6379 要连接redis的端口，默认是6379 -a 密码 指定redis的访问密码 其中的commonds就是Redis的操作命令，例如：\nping：与redis服务端做心跳测试，服务端正常会返回pong ![屏幕截图 2025-01-27 114601](C:/Users/20387/Pictures/Screenshots/屏幕截图 2025-01-27 114601.png)\n图形化界面 GitHub上的大神编写了Redis的图形化桌面客户端，地址：https://github.com/uglide/RedisDesktopManager\n不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。\n在下面这个仓库可以找到安装包：https://github.com/lework/RedisDesktopManager-Windows/releases\n建立连接 连接前要关闭centos防火墙systemctl stop firewalld 常用命令 命令参考\n数据结构 字符串（String） 基本特性：Redis 的字符串类型是二进制安全的，可以存储任何类型的数据，比如 JPG 图片或者序列化后的对象。 操作 SET key value：设置键值对。 GET key：获取键的值。 INCR key：将键的值增加 1。 DECR key：将键的值减少 1。 APPEND key value：在已有值的基础上追加数据。 哈希（Hash） 基本特性：哈希是键值对集合，适用于存储对象类型的数据，比如用户信息（字段：姓名、年龄、性别等）。 操作 HSET key field value：设置哈希表中的字段值。 HGET key field：获取哈希表中字段的值。 HGETALL key：获取哈希表中所有字段和值。 HMSET key field1 value1 field2 value2：设置多个字段的值。 HDEL key field：删除哈希表中的字段。 列表（List） 基本特性：列表是一个按顺序排列的字符串集合，支持从两端进行推入（push）和弹出（pop）。适合做消息队列等应用。 操作 LPUSH key value：将元素插入列表头部。 RPUSH key value：将元素插入列表尾部。 LPOP key：从列表头部弹出元素。 RPOP key：从列表尾部弹出元素。 LRANGE key start stop：返回列表中指定范围的元素。 集合（Set） 基本特性：集合是无序的字符串集合，不允许重复元素，适合用于去重等场景。 操作 SADD key member：将元素添加到集合中。 SREM key member：从集合中移除元素。 SMEMBERS key：获取集合中所有的元素。 SISMEMBER key member：检查元素是否存在于集合中。 SUNION key1 key2：返回两个集合的并集。 有序集合（Sorted Set，Zset） 基本特性：有序集合是一个包含分数（score）的字符串集合，每个元素都会关联一个分数，集合中的元素根据分数排序。 操作 ZADD key score member：添加元素及其分数。 ZRANGE key start stop：返回指定范围的元素（按分数排序）。 ZREM key member：移除元素。 ZINCRBY key increment member：给指定元素增加分数。 ZREVRANGE key start stop：返回指定范围的元素（按分数降序排序）。 位图（Bitmap） 基本特性：位图是一个特殊的字符串，可以在其中操作位（bit），适合做大规模的计数、状态标记等。 操作 SETBIT key offset value：设置指定位置的位值。 GETBIT key offset：获取指定位置的位值。 BITCOUNT key：统计键中为 1 的位的数量。 HyperLogLog 基本特性：HyperLogLog 是一种基数估计数据结构，适用于统计唯一元素的数量，能够在极低的内存消耗下提供近似值。 操作 PFADD key element：添加元素到 HyperLogLog。 PFCOUNT key：返回 HyperLogLog 中元素的基数估计值。 地理空间（Geospatial） 基本特性：Redis 提供了对地理空间的支持，可以存储和查询地理位置数据（经纬度）。 操作 GEOADD key longitude latitude member：添加地理坐标。 GEODIST key member1 member2：计算两个位置之间的距离。 GEORADIUS key longitude latitude radius：根据半径获取周围的地理位置。 流（Streams） 基本特性：流是一个用于处理数据流的结构，可以用于消息队列、事件记录等场景。 操作 XADD key * field value：向流中添加一条新消息。 XRANGE key start end：读取流中的消息。 XREAD key count block：阻塞式读取流中的消息。 发布/订阅（Pub/Sub） 基本特性：Redis 支持发布/订阅模式，允许客户端订阅某个频道，然后接收该频道发布的消息。 操作 PUBLISH channel message：向频道发布消息。 SUBSCRIBE channel：订阅频道。 UNSUBSCRIBE channel：取消订阅。 通用命令 key的层级结构：用冒号分隔\n例如：学校:班级:姓名\nKEYS\n查看所有符合模板的key\n通配符\nh?llo matches hello, hallo and hxllo\nh*llo matches hllo and heeeello\nh[ae]llo matches hello and hallo, but not hillo\nh[^e]llo matches hallo, hbllo, \u0026hellip; but not hello\nh[a-b]llo matches hallo and hbllo\n*？表示1个，表示多个，[ab]是a或者b，[a-b]是a到b，[ ^b ]是除了b\nDEL\n删除key\n1 DEL key1 (key2 key3 ... ...) EXISTS\n判断是否存在key\n1 EXISTS key EXPIRE\n设置key有效期\n1 EXPIRE key time（单位是s） TTL\n查看key有效期\n-1为永久有效\nString类型 类型，最大空间不超过512m 整数int 浮点float 普通字符串 常用命令 SET添加或修改\nSET key value\nGET\nMSET批量添加\nMSET k1 v1 k2 v2\nMGET批量获取\nINCR整数型自增1\nINCR key\n返回加1后的值\nINCRBY指定增长的数值，可为负数\nINCRBY key num\nINCRBYFLOAT\n浮点型自增，并指定增长的数值\nSETNX\n添加一个string类型，要key不存在， 存在则不执行\nSETNX key value等同于SET key value nx\nSETEX\nSETEX key num value在添加键值对时就设定有效期（num秒）\nHash类型 结构 一个 Hash 是由多个 字段（field） 和对应的 值（value） 组成的。每个字段和值都可以是字符串类型。\n与普通的字符串类型相比，Hash 类型的优势在于可以将多个值存储在同一个键下。\n常用命令 HSET key field1 value2 （field2 value2 … …） 添加和修改多个field的值 HGET key field 获取一个Hash类型的key的field的value HMGET key field1 field2 … … 获取key的多个field的值 HGETALL key 获取key的所有field和value HKEYS key 获取key的所有field HVALS key 获取key的所有value HINCRBY key field increment hash类型的key的整数型field指定增加量increment HINCRBYFLOAT key field increment Hash 类型中的字段执行浮点数的增减。 HSETNX key field value 添加一个Hash类型的key的field，前提是field不存在 List类型 List 类型 是一个双向链表，支持 正向检索 和 反向检索，即可以从头到尾（正向）或从尾到头（反向）访问、添加和删除数据。\n正向检索 是从左到右（插入顺序），通过正索引（如 0, 1, 2）访问。 反向检索 是从右到左（逆序），通过负索引（如 -1, -2, -3）访问。 特点 有序 元素可重复 插入删除快 查询速度一般 常用命令 LPUSH key value1 value2 … … 向list类型的key的左侧插入一个或多个元素\nLPOP key 移除并返回左侧第一个元素，没有则返回nil\nLPOP key [count] 要从左侧弹出的元素个数\nRPUSH key value1 value2 … … 向list类型的key的右侧插入一个或多个元素\nRPOP key 移除并返回右侧第一个元素，没有则返回nil\nLRANGE key start stop 返回列表中指定范围的元素。(下标从0开始)\nBLPOP和BRPOP 功能和 LPOP、RPOP 类似，但增加了阻塞功能，\n​ 不会直接返回nil,\n​ BLPOP key [key ...] timeout，其中timeout单位为秒\nSet类型 Set 类型是无序的、唯一的集合，可以存储多个不重复的元素\n特点 唯一性：集合中的元素是唯一的，不能重复。 无序性：集合中的元素是无序的，不能通过索引访问。 操作高效：添加、删除、判断是否存在的时间复杂度都是 O(1)O(1)O(1)。 支持集合运算：提供交集、并集、差集等操作。 常用命令 ","date":"2025-01-15T00:00:00Z","permalink":"https://suechinrry.github.io/p/redis/","title":"Redis"},{"content":"数据结构和算法 数组 数组是存放在连续内存空间上的相同类型数据的集合。\n下标从0开始 内存空间的地址是连续的 数组的元素不能删除只能覆盖 二分法 使用前提：有序数组，无重复元素\n二分法 left，right，middle只根据条件来改变left或right的值，middle的值自然会改变\n写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。\n两种写法的区别while循环条件不同，r的赋值不同\n写法1：[left, right]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int search(int[] nums, int target) { int l=0; int r=nums.length-1; int mid=0; while(l\u0026lt;=r){ mid= l + ((r - l) / 2); if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid-1; } else{ return mid; } } return -1; } } 将mid=（l+r）/2换成mid= l + ((r - l) / 2)的原因:当l和r都很大时，会导致溢出。\n写法2：[left,right)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int search(int[] nums, int target) { int l=0; int r=nums.length; int mid=0; while(l\u0026lt;r){ mid=l+(r-l)/2; if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid; } else{ return mid; } } return -1; } } 相关题目 35.搜索插入位置 N 暴力解法\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public int searchInsert(int[] nums, int target) { for(int i=0;i\u0026lt;nums.length;i++){ // 一旦发现大于或者等于target的num[i]，那么i就是我们要的结果 if(nums[i]\u0026gt;=target){ return i; } } return nums.length; } } 二分查找\n写法1：[l,r]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int searchInsert(int[] nums, int target) { int l=0; int r=nums.length-1; int mid=0; while(l\u0026lt;=r){ mid=l+(r-l)/2; if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid-1; } else{ return mid; } } //数组中未找到target元素 //target在数组所有元素之后，[left, right]是右闭区间，需要返回 right +1 return r+1; } } r 指针已经指向了数组中小于 target 的最后一个元素的位置\n34.在排序数组中查找元素的第一个和最后一个位置 含有重复元素时\n用两个二分法来查找左右边界\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int[] searchRange(int[] nums, int target) { int[] answer = new int[]{-1, -1}; int l = 0; int r = nums.length - 1; int mid = 0; int leftBorder = -1; int rightBorder = -1; // 查找左边界 while (l \u0026lt;= r) { mid = l + (r - l) / 2; if (nums[mid] \u0026gt;= target) { r = mid - 1; leftBorder = mid; // 更新左边界 } else { l = mid + 1; } } // 查找右边界 l = 0; r = nums.length - 1; while (l \u0026lt;= r) { mid = l + (r - l) / 2; if (nums[mid] \u0026lt;= target) { l = mid + 1; rightBorder = mid; // 更新右边界 } else { r = mid - 1; } } // 情况一：目标值不存在 if (leftBorder == -1 || rightBorder == -1 || nums[leftBorder] != target) { return new int[]{-1, -1}; } // 返回目标值的开始位置和结束位置 return new int[]{leftBorder, rightBorder}; } } 查找左边界的核心目标\n我们需要找到目标值在数组中最早出现的位置。在二分查找的过程中，r 和 l 指针会根据当前查找的值是否符合目标来不断调整。关键的思想是通过“收缩查找范围”来逼近目标值的左边界。\n为什么使用 r 来确定左边界？\n当 nums[mid] \u0026gt;= target 时，我们可以确定目标值可能在当前位置 mid 或 mid 左侧的区间。 为什么是左侧？ 因为我们正在寻找左边界，而且数组是非递减顺序排列的。如果当前 nums[mid] 大于或等于目标值，目标值可能出现在 mid 或它的左边。 例如，如果目标值是 8，在 [5, 7, 7, 8, 8, 10] 这样的数组中，8 出现了两次。你需要确定目标值第一个出现的位置。即便在 mid 处找到了 8，我们还需要继续查找 mid 左侧，看看是否存在更早的 8。 收缩右边界 r = mid - 1，这样我们就会继续在 mid 左边的区间进行查找。因为目标值可能出现在 mid 或它的左侧。 更新 leftBorder = r： 当 nums[mid] \u0026gt;= target 时，目标值在 mid 或它的左边，所以我们更新 r 位置为左边界的位置（r 逐步逼近目标值的左侧）。 这时，leftBorder 记录的其实是当前 mid 左侧的一个边界，而不是 mid 本身。因为如果 nums[mid] \u0026gt;= target，说明目标值应该在 mid 或左边，所以我们更新左边界为 r，以便后续判断是否存在更小的值。 leftBorder == -1\nleftBorder 用来记录目标值在数组中最左边的出现位置。如果 leftBorder 为 -1，意味着在查找左边界的过程中没有找到目标值。也就是说，目标值在数组中不存在，所以此时应该返回 [-1, -1]，表示目标值不存在。\n为什么是 -1？ 在查找过程中，leftBorder 的初始值是 -1，只有当查找到目标值时才会更新 leftBorder。如果最终没有找到目标值，leftBorder 仍然保持为 -1。 nums[leftBorder] != target\n这一部分检查在找到的 leftBorder 位置是否真的等于目标值 target。也就是说，即使 leftBorder 不等于 -1，我们还需要确认 nums[leftBorder] 这个位置的值是否确实是目标值 target。\n为什么要做这个检查？ 可能出现一种情况：假设目标值并未出现在数组中，但二分查找的过程可能仍然会更新 leftBorder 为某个位置。为了确保 leftBorder 位置的值确实是目标值，我们需要进行额外的检查。只有当 nums[leftBorder] == target 时，才说明 leftBorder 是有效的目标值出现位置。 组合解释：\n如果 leftBorder == -1，表示目标值在数组中不存在，所以直接返回 [-1, -1]。 如果 rightBorder == -1，同样表示目标值在数组中不存在，所以也返回 [-1, -1]。 如果 nums[leftBorder] != target，说明 leftBorder 虽然不是 -1，但是找到了一个错误的位置，或者在 leftBorder 位置并没有找到目标值。因此，也应该返回 [-1, -1]。 为什么是 leftBorder = mid 而不是 leftBorder = r？\n查找左边界的目标是找到 目标值第一次出现的位置。在二分查找的过程中，当 nums[mid] \u0026gt;= target 时，说明目标值可能在 mid 或它的左边，所以我们需要继续往左侧查找，并且 mid 是可能的左边界。\n如果 nums[mid] \u0026gt;= target，说明目标值可能在 mid 位置或其左边\n：\n为什么mid 是可能的左边界？ 假设数组是 [5, 7, 7, 8, 8, 10]，我们要查找目标值 8。 当我们在 mid = 3 时，发现 nums[mid] == 8，这时我们知道 8 出现在 mid 位置或者它左边的位置。 因为我们要找到 第一次出现的位置，即最左边的目标值，所以即使在 mid 处找到了目标值，我们仍然需要继续向左查找。 69.x 的平方根 N 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int mySqrt(int x) { if (x == 0) return 0; int l=1; int r=x; int mid=0; while(l\u0026lt;=r){ mid=l+(r-l)/2; if(x/mid\u0026lt;mid){ r=mid-1; } else if(x/mid\u0026gt;mid){ l=mid+1; } else{ return mid; } } return r; } } 为了防止溢出，将mid*mid\u0026gt;x换位x/mid\u0026lt;mid 二分查找最终会使得 l \u0026gt; r，此时区间 [l, r] 会被缩小到一个无法继续分割的状态。此时，r 就是比 sqrt(x) 小的最大整数。 367.有效的完全平方数 移除元素 移除元素 N 暴力解法，两层for循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int removeElement(int[] nums, int val) { int n=nums.length; for(int i=0;i\u0026lt;n;i++){ if(nums[i]==val){ for(int j=i+1;j\u0026lt;n;j++){ nums[j-1]=nums[j]; } n--;//长度减一 i--;//下一次还是得从现在这个位置开始。 } } return n; } } 双指针\nfast遍历整个数组，slow用来指向更新新数组下标的位置。\n其实count没必要\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int removeElement(int[] nums, int val) { int slow=0; int count=0; for(int fast=0;fast\u0026lt;nums.length;fast++){ if(nums[fast]!=val){//不是目标数就进行更新，将下标为fast的值更新到下标slow nums[slow]=nums[fast]; slow++; count++; } //与目标值相等就不做处理，等待被覆盖 } return count; } } 相关题目 26.删除排序数组中的重复项 N 第一个元素不用处理，从第二个元素开始。所以slow的初始值是1，fast的初始值也为1，而且为了避免下标溢出，将nums[fast]!=nums[fast+1]换成nums[fast]!=nums[fast-1]。\nslow 指针始终指向下一个应该放置去重后元素的位置。每当我们遇到一个不重复的元素时，我们就将其放入 nums[slow] 位置，并且增加 slow 的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int slow=1; for(int fast=1;fast\u0026lt;nums.length;fast++){ if(nums[fast]!=nums[fast-1]){ nums[slow]=nums[fast]; slow++; } } return slow; } } 283.移动零 844.比较含退格的字符串 ==对于数组，直接使用 length，不加括号。==\n==对于字符串，使用 length() 方法，记得加括号。==\nStringBuilder 和 StringBuffer 可变的字符串类\n如果你只在单线程环境中操作字符串，使用 StringBuilder 更好，因为它性能更优。 如果你需要在多线程环境中操作同一个字符串对象，使用 StringBuffer，它提供了线程安全保证，但性能可能稍逊色。 以下类和接口可以用作栈：\nStack（传统栈类） Deque（推荐，使用 ArrayDeque 或 LinkedList 实现） LinkedList（兼容双端队列和栈） 自定义栈（数组或链表实现） 线程安全的栈（如 Collections.synchronizedDeque 包装的 Deque） 优先推荐使用 Deque 接口（如 ==ArrayDeque==），因为它性能更高且设计更现代化。\n栈相关方法：\nArrayDeque 实现了 Deque 接口，支持以下与栈相关的方法：\npush(E e)\n将元素压入栈（队列的头部）。 等同于 addFirst()。 时间复杂度：O(1)。 1 2 3 ArrayDeque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push(1); // 入栈 stack.push(2); // 入栈 pop()\n移除并返回栈顶元素（队列的头部元素）。 等同于 removeFirst()。 如果栈为空，调用此方法会抛出 NoSuchElementException。 时间复杂度：O(1)。 1 int element = stack.pop(); // 出栈，输出 2 peek()\n返回栈顶元素，但不移除它（查看队列的头部元素）。 等同于 peekFirst()。 如果栈为空，返回 null。 时间复杂度：O(1)。 1 int top = stack.peek(); // 查看栈顶元素，输出 1 isEmpty()\n判断栈是否为空。 时间复杂度：O(1)。 1 boolean isEmpty = stack.isEmpty(); // 判断栈是否为空 size()\n返回栈的元素个数。 时间复杂度：O(1)。 1 int size = stack.size(); // 返回栈的大小 977.有序数组的平方 N 暴力\n1 2 3 4 5 6 7 8 9 class Solution { public int[] sortedSquares(int[] nums) { for(int i=0;i\u0026lt;nums.length;i++){ nums[i]=nums[i]*nums[i]; } Arrays.sort(nums); return nums; } } 双指针排序\n左边从0开始，右边从length-1开始。\n因为数组是按照非递减排列的，所以说右边的数大于等于左边。\n==这道题求的是平方大的。==\nnums[left]与nusm[right]相加。大于0，则说明right下标的数要大些；小于0，就说明left下标的绝对值要大些\n==这个比较相加大于0小于0代替比较两个数的平方的大小。==\n比较完后，将得到的结构写道新的数组里，而且还要移动左或者右指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int[] sortedSquares(int[] nums) { int left=0; int right=nums.length-1; int[] answer=new int[nums.length]; int i=nums.length-1; while(left\u0026lt;=right){ if(nums[left]+nums[right]\u0026lt;0){ answer[i]=nums[left]*nums[left]; left++; } else{ answer[i]=nums[right]*nums[right]; right--; } i--; } return answer; } } 若仅仅按照大小排列则为以下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int[] sortedArray(int[] nums) { int left = 0; // 左指针 int right = nums.length - 1; // 右指针 int[] answer = new int[nums.length]; // 用于存储结果 int i = 0; // 从结果数组的开头开始填充 while (left \u0026lt;= right) { if (nums[left] \u0026lt;= nums[right]) { answer[i] = nums[left]; left++; } else { answer[i] = nums[right]; right--; } i++; } return answer; } } 长度最小的子数组 长度最小的子数组 这道题的子数组数连续的\n暴力\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int minSubArrayLen(int target, int[] nums) { int sum=0; int min=Integer.MAX_VALUE; for(int i=0;i\u0026lt;nums.length;i++){ sum=0; for(int j=i;j\u0026lt;nums.length;j++){ sum+=nums[j]; if(sum\u0026gt;=target){ min=Math.min(min,j-i+1); break; } } } return min==Integer.MAX_VALUE?0:min; } } 滑动窗口（双指针）\n只用一个for循环，这个循环是确定终止位置的\nfor循环里，for(int end=0; end\u0026lt;nums.length; end++)；扩大窗口，每次通过 sum+=nums[end] 增加当前窗口的和。\n如果加上后大于target，则开始移动start。（开始移动是指移动到sum不满足大于target为止，所以需要用while而不是if，并且每次移动后都要记录最小子数组的长度）\n为什么start不需要再每次for循环时重置为0？\n因为，sum满足大于target这个条件时（ while(sum\u0026gt;=target)）,会尝试减小，减小值为当前nums[start]，sum的和就不会再包含当前start下标的值了。如果每次循环都重置为0，就会删除sum本身不包含的数，会导致错误。\n下面是gpt的回答：\n为什么 start 不需要在每次 for 循环时重置为 0？\n滑动窗口的动态调整机制 在滑动窗口算法中，start 的作用是 调整窗口的左边界，使得当前窗口的和 (sum) 满足问题的要求（比如大于等于 target）。 一旦 sum \u0026gt;= target，我们通过移动 start（即增加 start 的值），缩小窗口的左边界，同时从 sum 中减去 nums[start] 的值。这种操作是基于当前窗口的状态进行的，不需要从头（start = 0）重新开始调整。 如果每次外层循环都重置 start = 0，就会丢失滑动窗口算法的核心逻辑，即在前一次窗口调整的基础上继续调整，这会导致重复计算和逻辑错误。 为什么不能删除不属于当前窗口的值？ 如果 start 被重置为 0，我们就会尝试减去 nums[start]（比如 nums[0]），但这些值可能已经被移出了当前窗口（while(sum \u0026gt;= target) 的过程中已经移除了）。此时的 sum 已经不再包含这些值，减去它们会导致错误的计算。 动态收缩窗口 vs 重置窗口 动态收缩窗口：每次 sum \u0026gt;= target 时，只通过增加 start 的方式调整窗口，确保窗口和始终基于当前窗口的实际范围。 重置窗口：如果每次外层循环都将 start 重置为 0，就会导致每次都从头开始重新计算窗口。这种做法会让算法丢失滑动窗口的高效性，同时也会引入逻辑错误（因为 sum 不包含窗口外的值）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int minSubArrayLen(int target, int[] nums) { int start=0; int sum=0; int min=Integer.MAX_VALUE; for(int end=0;end\u0026lt;nums.length;end++){ sum+=nums[end]; while(sum\u0026gt;=target){ sum-=nums[start]; min=Math.min(min,end-start+1); start++; } } return min==Integer.MAX_VALUE?0:min; } } 相关题目 904.水果成篮 N 先减少水果数量，再检查是否移除水果键。不然会移除一个不存在的键而报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int totalFruit(int[] fruits) { int left=0; int max=Integer.MIN_VALUE; Map\u0026lt;Integer,Integer\u0026gt; fruitsMap=new HashMap\u0026lt;\u0026gt;(); for(int right=0;right\u0026lt;fruits.length;right++){ fruitsMap.put(fruits[right],fruitsMap.getOrDefault(fruits[right],0)+1); while(fruitsMap.size()\u0026gt;2){ fruitsMap.put(fruits[left],fruitsMap.get(fruits[left])-1); if(fruitsMap.get(fruits[left])==0){ fruitsMap.remove(fruits[left]); } left++; } max=Math.max(max,right-left+1); } return max; } } 76.最小覆盖子串 N 螺旋矩阵2 59. 螺旋矩阵 II - 力扣（LeetCode） N 确定好外循环，外循环是一共要转多少圈，n为奇数时单独的一个数不算一圈。这样的话奇数和偶数就统一了，所需圈数都为n/2\n内循环，转一次圈需要四个。采用左闭右开[ )。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int[][] generateMatrix(int n) { int[][] answer = new int[n][n]; int loop=0; int startx=0,starty=0; int i=0,j=0; int offset=1,count=1; while(loop\u0026lt;n/2){//n为偶数就刚好转n/2圈 //向右,目前i=0,j=starty for(j=starty;j\u0026lt;n-offset;j++){ answer[startx][j]=count++; } //向下，目前j=n-offset了 for(i=startx;i\u0026lt;n-offset;i++){ answer[i][j]=count++; } //向左,目前i=n-offset，j=n-offset for(;j\u0026gt;starty;j--){ answer[i][j]=count++; } //向上，目前i=n-offset，j=starty for(;i\u0026gt;startx;i--){ answer[i][j]=count++; } startx++; starty++; offset++; loop++; } if(n%2!=0){//n为奇数，还需要加上最里面的一个单独的数 answer[startx][starty]=count; } return answer; } } 类似题目 54.螺旋矩阵 N 如果min(rows, columns)为偶数，则不需要在最后单独考虑矩阵最中间位置的赋值 如果min(rows, columns)为奇数 m\u0026gt;n，会剩下一个中间列 m\u0026lt;n，会剩下一个中间行 m=n，会剩下一个中间数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public List\u0026lt;Integer\u0026gt; spiralOrder(int[][] matrix) { ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); int m = matrix[0].length; int n = matrix.length; int a = 0; int i,j; int startx = 0, starty = 0; int loop = Math.min(m, n) / 2; int mid = loop; int offset = 1; while (loop \u0026gt; 0){ for(j = starty; j \u0026lt; m -offset; j++) list.add(matrix[startx][j]); for(i = startx; i \u0026lt; n - offset; i++) list.add(matrix[i][j]); for(; j \u0026gt; starty; j--) list.add(matrix[i][j]); for(; i \u0026gt; startx; i--) list.add(matrix[i][j]); startx++; starty++; loop--; offset++; } if ((Math.min(m,n)%2) != 0 ) { if(m \u0026gt; n){ for ( j = mid; j \u0026lt; mid + m - n + 1; ++j) { list.add(matrix[mid][j]); } } else { for ( i = mid; i \u0026lt; mid + n - m + 1; ++i) { list.add(matrix[i][mid]); } } } return list; } } 剑指Offer 29.顺时针打印矩阵 将ArrayList转换成int数组\n1 res.stream().mapToInt(Integer::intValue).toArray(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public int[] spiralArray(int[][] array) { if (array == null || array.length == 0 || array[0].length == 0) { return new int[0]; } List \u0026lt;Integer\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); int m=array.length,n=array[0].length; int startx=0,starty=0; int i,j; int loop=0,offset=1; while(loop\u0026lt;Math.min(m,n)/2){ for(j=starty;j\u0026lt;n-offset;j++){ res.add(array[startx][j]); } for(i=startx;i\u0026lt;m-offset;i++){ res.add(array[i][j]); } for(;j\u0026gt;starty;j--){ res.add(array[i][j]); } for(;i\u0026gt;startx;i--){ res.add(array[i][j]); } loop++; startx++; starty++; offset++; } if(Math.min(m,n)%2!=0){ if(m\u0026gt;n){//中间列 for(int k=n/2;k\u0026lt;n/2+m-n+1;k++){ res.add(array[k][starty]); } } else{//m\u0026lt;n中间行 m=n中间元素 for(int k=m/2;k\u0026lt;m/2+n-m+1;k++){ res.add(array[startx][k]); } } } return res.stream().mapToInt(Integer::intValue).toArray(); } } 链表 关于链表 链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。\n种类 单链表 双链表 循环链表 存储方式 链表在内存中可不是连续分布的。\n链表是通过指针域的指针链接在内存中各个节点。\n操作 删除节点\n203. 移除链表元素 - 力扣（LeetCode）\n不用虚拟节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public ListNode removeElements(ListNode head, int val) { //若头节点符合删除头节点 while(head!=null\u0026amp;\u0026amp;head.val==val){ head=head.next; } ListNode cur=head; while(cur!=null\u0026amp;\u0026amp;cur.next!=null){ if(cur.next.val==val){ cur.next=cur.next.next; } else{ cur=cur.next; } } return head; } } 使用虚拟节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode removeElements(ListNode head, int val) { ListNode dummy=new ListNode(Integer.MAX_VALUE,head); ListNode cur=dummy; while(cur.next!=null){ if(cur.next.val==val){ cur.next=cur.next.next; } else{ cur=cur.next; } } return dummy.next; } } 添加节点\n707. 设计链表 - 力扣（LeetCode） 206. 反转链表 - 力扣（LeetCode） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode reverseList(ListNode head) { ListNode res = null; // 反转后的链表头初始化为null ListNode cur = head; // 当前节点指向原链表的头 while (cur != null) { // 循环直到遍历完整个链表 ListNode temp = cur; // 保存当前节点 cur = cur.next; // 移动cur到下一个节点 temp.next = res; // 当前节点指向反转后的链表头 res = temp; // 更新反转链表头 } return res; // 返回反转后的链表头 } } . while(cur.next != null) -\u0026gt; while(cur != null) 原代码：\n1 while (cur.next != null) 问题：\ncur.next != null 只会判断当前节点的下一个节点是否存在，如果是最后一个节点，cur.next 为 null，则会跳出循环，导致最后一个节点没有被反转并丢失。 我们希望遍历链表中的所有节点，不论是中间节点还是最后一个节点，所以条件应该是 cur != null。 修改后：\n1 while (cur != null) 这样，循环会继续直到 cur 为 null，即遍历整个链表，保证所有节点都能被反转。\n为什么一定要将cur后移一位的操作放在对res操作之前\nChatGPT 说： ChatGPT\n将 cur 后移一位的操作放在对 res 操作之前的主要原因是为了 保护链表的完整性，避免丢失未处理的节点。如果不先移动 cur 而直接修改 res，链表中的某些节点可能会失去引用，导致链表断裂或顺序错乱。\n核心逻辑： 在反转链表过程中，cur 指针是负责遍历原链表的。如果在处理 res（反转链表的头指针）之前没有将 cur 后移到下一个节点，当当前节点的 next 被修改时，原链表中后续节点的信息会丢失。\n示例分析 假设我们有一个链表：\n1 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; null 正确操作顺序（先移动 cur）： 当前节点是 cur = 1，res = null。\n保存当前节点：temp = cur（即 temp = 1）。 先移动 cur：cur = cur.next（即 cur = 2）。 修改当前节点指针：temp.next = res（即 1.next = null）。 更新反转链表头：res = temp（即 res = 1）。 结果：\n1 2 rust复制编辑原链表：2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; null 反转链表：1 -\u0026gt; null 当前节点是 cur = 2，重复以上操作，直到整个链表被反转。\n错误操作顺序（不先移动 cur）： 当前节点是 cur = 1，res = null。\n保存当前节点：temp = cur（即 temp = 1）。 直接修改 temp.next：temp.next = res（即 1.next = null）。 更新反转链表头：res = temp（即 res = 1）。 然后移动 cur：cur = cur.next（此时 cur = 1.next）。 问题：\n1.next 已经被修改为 null，因此 cur = cur.next 得到的是 null。 原链表中剩余的节点 2 -\u0026gt; 3 -\u0026gt; 4 被丢失。 最终导致链表断裂，无法继续处理。\n24. 两两交换链表中的节点 - 力扣（LeetCode） half-N 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public ListNode swapPairs(ListNode head) { ListNode dumy=new ListNode(); dumy.next=head; ListNode first; ListNode second; ListNode cur=dumy; while(cur.next!=null\u0026amp;\u0026amp;cur.next.next!=null){ first=cur.next; second=cur.next.next; cur.next=second; first.next=second.next; second.next=first; cur=first; } return dumy.next; } } 为什么需要dummy节点？\ndummy节点作为占位头节点，可以统一处理链表头部的交换操作，避免头节点变化时的特殊处理。例如，当原链表只有两个节点时，交换后的新头节点是第二个节点，dummy.next能直接指向它。\ncur.next!=null\u0026amp;\u0026amp;cur.next.next!=null为什么循环终止条件必须是这个?\n要交换两个节点，必须保证当前节点后至少有两个节点。若cur.next或cur.next.next为空，说明剩余节点不足两个，无需继续交换。\ncur = first的作用是什么？\n交换完成后，cur移动到已处理部分的末尾（即原第一个节点），作为下一对节点的前驱节点。例如，交换1-\u0026gt;2后，cur移动到1的位置，以便处理后续的3-\u0026gt;4\ntodo可以用递归做\n19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode） 不使用虚拟头节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if(head==null||head.next==null){ return null; } int count=0; ListNode cur=head; while(cur!=null){ cur=cur.next; count++; } cur=head; count=count-n; //处理删除值为头节点 if(count==0){ return head.next; } while(count\u0026gt;1){ cur=cur.next; count--; } cur.next=cur.next.next; return head; } } 不使用虚拟头节点，所以要处理head为空和head.next为空的特殊情况 删除head所指的节点，要单独处理 使用虚拟头节点+双指针 双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dumy=new ListNode(); dumy.next=head; ListNode fast=dumy; ListNode slow=dumy; for(int i=0;i\u0026lt;n;i++){ fast=fast.next; } while(fast.next!=null){ slow=slow.next; fast=fast.next; } slow.next=slow.next.next; return dumy.next; } } 循环结束条件必须是fast.next!=null,这样fast才会停在最后一个有效节点上，slow才会停在待删除节点前一个节点。\n如果是fast！=null的话，fast会多走一次，停在最后一个有效节点的next上（即null上）。\n面试题 02.07. 链表相交 - 力扣（LeetCode） 方法一 headA.next==null\u0026amp;\u0026amp;headB.next==null时，也有成立的可能（例如headA为[1]，headB为[1]），不应该直接返回null。\n计算链表长度的循环条件\ncount=0，循环条件为cur!=null。若是使用cur.next!=null，则会停止在最后一个有效节点上，count=长度-1。\n遍历链表的循环条件\n​ 正确循环：fast!=null\u0026amp;\u0026amp;slow!=null，这样不会遗漏最后一个有效节点\n​ 错误循环：fast.next!=null\u0026amp;\u0026amp;slow.next!=null，这样只是停在了最有一个有效节点，但是不能操作这个有效节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA==null||headB==null){ return null; } int countA=0,countB=0; ListNode cur=headA; while(cur!=null){ cur=cur.next; countA++; } cur=headB; while(cur!=null){ cur=cur.next; countB++; } ListNode fast; ListNode slow; if(countA\u0026gt;countB){ fast=headA; slow=headB; } else{ fast=headB; slow=headA; } for(int i=0;i\u0026lt;Math.max(countA,countB)-Math.min(countA,countB);i++){ fast=fast.next; } while(fast!=null\u0026amp;\u0026amp;slow!=null){ if(fast==slow){ return fast; } fast=fast.next; slow=slow.next; } return null; } } 方法二： todo合并链表实现同步移动\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // p1 指向 A 链表头结点，p2 指向 B 链表头结点 ListNode p1 = headA, p2 = headB; while (p1 != p2) { // p1 走一步，如果走到 A 链表末尾，转到 B 链表 if (p1 == null) p1 = headB; else p1 = p1.next; // p2 走一步，如果走到 B 链表末尾，转到 A 链表 if (p2 == null) p2 = headA; else p2 = p2.next; } return p1; } } 142. 环形链表 II - 力扣（LeetCode） 使用快慢指针，快指针会和慢指针在环内相遇。这样可以判断有无环\n计算循环链表入口\n![](屏幕截图 2025-01-31 185531.png)\nfast指针一次走两格\nslow指针一次走一格\n相遇时，fast走x+y+n(y+z)，slow走x+y。并且fast走的时slow的两倍\n即(x + y) * 2 = x + y + n (y + z)\n两边消掉一个（x+y）: x + y = n (y + z)\n因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。\n所以要求x ，将x单独放在左面：x = n (y + z) - y ,整理后得x = (n - 1) (y + z) + z\n当n等于1时，x=z。说明两个指针，一个指向head（index1），另一个指向fast和slow的相遇点（index2），当两指针相遇，index1就是环形入口。\nn如果大于1，就是fast指针在环形转n圈之后才遇到 slow指针。\n其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。\n循环条件\n为什么循环条件是fast!=null\u0026amp;\u0026amp;fast.next!=null而不是fast.next!=null\u0026amp;\u0026amp;slow!=null 当 fast 为空时，仍可能尝试访问 fast.next，导致 NullPointerException。 slow 是否为空并不会影响 fast 的运行逻辑，加入 slow != null 没有意义。 在处理链表问题时，如果循环条件是基于 fast.next != null 进行判断，一定要带上 fast != null，否则可能会导致 NullPointerException ","date":"2025-01-13T22:27:13+08:00","image":"https://suechinrry.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/lst_hu_1525ede3a30447c3.jpg","permalink":"https://suechinrry.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","title":"数据结构与算法"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","permalink":"https://suechinrry.github.io/p/placeholder-text/","title":"Placeholder Text"}]