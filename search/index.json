[{"content":"Linux 安装Linux 安装虚拟机 下载：\nhttps://softwareupdate.vmware.com/cds/vmw-desktop/ws/17.6.2/24409262/windows/core/VMware-workstation-17.6.2-24409262.exe.tar\n检查虚拟网卡：\nwin+r 输入 ncpa.cpl，检查有无虚拟网卡VMnet1和VMnet8\n安装Linux centOS7下载：Index of /7.6.1810/isos/x86_64\n新建虚拟机，选择典型 选择文件 设置名称、密码 放到D盘 更改最大磁盘大小为40GB 启动 快照 打开快照管理器 选择一个快照进行跳转 远程连接Linux 通过第三方软件：FinalShell\n下载网址 FinalShell官网\n连接操作 打开vm虚拟机 打开终端，输入ifconfig，获取ip 用finalshell进行连接 建立连接，双击启动 Linux相关 linux的目录结构 /为根路径。 例如： /user/test/hello.txt\n命令和命令行 命令：一个命令就是一个linux程序，没有图形化界面，可以在命令行提供字符化反馈\n命令行：linux终端，是一种命令提示符页面\n命令格式 在 Linux 中，命令的一般格式如下：\n1 command [options] [arguments] command：要执行的命令，比如 ls、cd、cp 等。 options（可选项）：修改命令行为的选项，通常以一个或两个连字符（- 或 --）开头。例如：-l、--help。 arguments（参数，可选项）：命令操作的对象，通常是文件名、目录名或者其他需要命令处理的内容 Home目录和工作目录 Home目录：每个用户通常都会在 /home 目录下有一个以用户名命名的子目录，作为该用户的主目录。 例如：==/home/用户名==\n工作目录：命令行在执行命令时，需要一个工作目录，默认设置工作目录在该用户的home目录\n特殊路径符 . 表示当前目录，例如：cd ./desktop等同于 cd desktop .. 表示上级目录，例如：cd ..就是返回上一级，cd ../..就是返回上两级 ~ 表示home目录，例如：cd ~等同于cd 命令 ls命令 1 ls [-a -l -h] [linux路径] 作用：列出当前目录的内容，默认为home目录\n-a：-all，列出全部文件夹，包括隐藏的文件/文件夹（==文件或文件夹以 . 开头就能自动隐藏==）\n-l：以列表（竖向）展示内容，并且展示更多的信息。包含==权限信息，所属用户，所属用户组==\n-h：可读格式显示文件大小\n==混合使用==：\n例如：同时使用-a和-l\n写法一：-a -l 写法二：-al，-la 目录切换相关命令 cd 1 cd [linux路径] 带参数：切换到指定目录 不带参数：切换到home目录 pwd 1 pwd 查看当前工作目录\n创建目录命令 mkdir创建目录 只有在home目录下才有创建目录的权限\n1 mkdir [-p] [linux路径] 创建新的目录\n不带选项：创建目录时要求父目录必须存在。如果父目录不存在，则会报错。 -p：用于创建多级目录，如果某个中间目录不存在，-p 会自动创建它们，而不会报错。例如： 1 mkdir -p /home/用户名/project/src 如果 /home/user/project/ 和 /home/user/project/src 目录不存在，mkdir -p 会依次创建它们。如果目录已经存在，它也不会报错。\nmkdir 只会创建目录，不会切换到新目录。 在ls -l命令下的==以d开头的是文件夹，以-开头的是文件==。\n文件操作命令 touch新建文件 1 touch [linux路径] 例如：touch test.txt\n查看文件内容 cat 1 cat [linux路径] 例如：cat test.txt\n==直接显示全部内容==\nmore 1 more [linux路径] 例如：more test.txt\n==可以翻页查看文件，空格是翻到下一页，q是退出查看==\ncp复制文件或文件夹 1 cp [-r] 参数1 参数2 -r：复制文件夹时需要添加-r 参数1：是被复制的文件（文件夹） 参数2：是要复制到的地方 mv移动文件或文件夹 1 mv 参数1 参数2 参数1：是被移动的文件（文件夹） 参数2：是要移动到的地方 mv也可以用来重命名文件，例如：mv test1.txt test2.txt，将test1重命名为test2 rm删除文件或文件夹 1 rm [-r -f] 参数1 参数2 ... ... 参数n -r：和cp一样，-r用于操作文件夹 -f：强制删除，强制删除不会有提示。普通用户删除内容不会有提示，root用户删除内容时才有提示。（普通用户一般用不到-f）。 参数1 参数2 \u0026hellip; \u0026hellip; 参数n，参数代表要删除的文件或路径，用空格隔开。 通配符 *\nabc* 表示以abc开头\n*abc * 表示含有abc的\n*abc 表示以abc结尾的\nwhich查找命令所在位置 1 which 要查找的命令 例如：which cd，which cp等\nfind查找文件所在位置 按文件名查找\n1 find 起始路径 -name 文件名 有空格或特殊字符时，打引号，“文件名” 例如，在/路径下查找文件名为aaa的所在位置， find / -name “aaa”\n按文件大小查找\n1 find 起始路径 -size +(或-)n[kMG] +：表示大于 -：表示小于 n：数字n表示文件大小 kMG：k为KB，M为MB，G为GB 例如，要查找大于500KB的文件，find ~ -size +500k\ngrep筛选文件中特定的行 1 grep [-n] 关键字 文件路径 建议关键字打引号，==有空格或特殊字符时==，“关键字” -n：显示匹配模式的行号。 文件路径：==可作为内容输入端口== wc统计文件内容 1 wc [-l -w -c -m] 文件路径 -l：显示行数。 -w：显示单词数。 -c：显示字节数（通常是文件的大小。 -m：显示字符数（与字节数略有不同，主要是对多字节字符集（如 UTF-8）的处理。 不使用任何选项，wc 命令会默认输出 行数、单词数和字节数 三项统计信息。 tail查看文件尾部的内容 1 tail [-f -数字] linux路径 -f：表示持续监视文件的变化，并显示新增的内容。 -数字：不写默认查看后10行。写了，例如，-5即为查看后5行。 切换root用户 su - root ，密码和普通用户的一样 输入exit退出root echo让命令行输出指定内容 1 echo 想要命令行输出的内容 有空格或特殊字符时，建议打引号。\n管道符 | 将左边命令的结果作为右边命令的输入。\n类似于，左边命令的输出（标准输出）会作为==数据源==传递给右边命令的输入（标准输入）\n反引号`` 被包围的内容，会==被当作命令执行==\n重定向符 输出重定向\u0026gt;：将左边命令的结果覆写到符号右边的文件中 追加重定向\u0026gt;\u0026gt;：将左边命令的结果追加写到符号右边的文件中 vim编辑器 vim是vi的加强版本，vim是文本编辑器\n工作模式\n命令模式，输入模式，底线命令模式。\n命令模式\n进入命令模式\n1 vim 文件路径 文件存在，则用于编辑已有文件；若不存在，则编辑新文件。\n进入输入模式\n按 i、a、o 等键进入输入模式，不同字母光标位置不同，进行编辑。\n按 i：在光标当前位置进入输入模式。\n按 I：在当前行的第一个非空字符前进入输入模式。\n按 a：在光标当前位置后进入输入模式（即光标后一个字符开始输入）。\n按 A：在当前行的末尾进入输入模式。\n按 o：在当前行下面新建一行并进入输入模式。\n按 O：在当前行上面新建一行并进入输入模式。\n快捷键操作\n进入底线命令模式\n按 : 键进入底线命令模式\n输入模式\n按esc退出，进入命令模式\n底线命令\n按wq，保存并退出vim\n按q！，强制退出\n用户和权限 普通用户在home目录下，权限不受限。出了home目录只有只读和执行的权限，无修改权限。\nsu切换用户 1 su [-] [用户名] -：带-表示切换用户后加载环境变量。 退出通过exit 普通用户切换到其他用户需要密码，root用户不用 不写用户名，即su -，会切换到root用户 sudo授权 给普通命令授权，临时以root用户身份执行。\n1 sudo 命令 前提：获得sudo认证\n使用root用户，使用visudo命令\n在文件的最后一行添加\n1 用户名 ALL=(ALL)\tNOPASSWD:ALL :wq保存并退出\n用户和用户组 用户组管理 创建用户组\n1 groupadd 用户组名 删除用户组\n1 groupdel 用户组名 用户管理 创建用户\n1 useradd [-g -d] 用户名 -g：-g 用户组名，将用户添加到已存在的用户组中。不带-g，会自动创建同名的用户组并加入 -d：-d home目录，可以自定义home目录。不带则默认为/home/用户名 删除用户\n1 userdel [-r] 用户名 -r：带了就连同home目录一起删除，不带则只删除用户不删除home目录 查看用户所属组\n1 id 用户名 不带用户名则查看自身\n修改用户所属组\n1 usermod -aG 用户组 用户 查询所有用户\n1 getent passwd 查询所有用户组\n1 getent group 权限信息 ls -l展示出的信息中\n![](屏幕截图 2025-01-20 215232.png)\n其中r为读权限，w为写权限，x为执行权限\nchmod修改权限信息 1 chmod [-R] 权限 文件或文件夹 -R：对文件夹的全部内容应用同样操作\n例如：chmod u=rwx,g=rx,o=x test.txt\n其中u为所属用户的权限，g为所属用户组的权限，o为其他用户的权限\n简化写法：\n类似于rwx最小项。- - x表示001，即为1。\n上面示例可简化为：chmod 751 test.txt\nchown改变所属 只适用于root用户\n1 chown [-R] [用户][:用户组] 文件或文件夹 -R：对文件夹的全部内容应用同样操作 快捷键 ctrl+c 强制停止\nctrl+d 退出\n不能用于退出vi或者vim\nhistory 查看历史命令\n!内容自动匹配并执行历史记录中最近的一条\nctrl+r 输入内容去匹配历史命令。回车后可直接执行这条历史命令；按左or右键得到该命令\nctrl+l 清屏，等同于clear命令\n软件安装 yum命令安装软件 使用报错\n先检查是不是网络连接的问题\n若不是，则（以下操作均需要root权限）\n下载阿里云的镜像源配置文件\n1 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 清理旧缓存\n1 yum makecache PackageKit 服务占用了 Yum 的锁\n暂停并终止 PackageKit 服务\n1 systemctl stop packagekit 禁用 PackageKit 服务\n1 systemctl disable packagekit rpm是linux的安装包格式\n1 yum [-y] [install | remove | search] 软件名称 -y：自动安装，无需手动确认安装或卸载 yum命令==需要root权限或sudo提权== systemctl命令控制软件的关闭和启动 1 systemctl [start | stop | restart | reload | status | enable | disable] 服务名称 start：启动某个服务。\nstop：停止某个服务。\nrestart：重启某个服务。\nreload：重新加载某个服务的配置，不重启服务。\nstatus：查看某个服务的当前状态。\nenable：设置服务开机启动。\ndisable：禁用服务的开机启动。\nsystemctl 不仅可以控制系统内置的服务，还可以控制一些第三方软件和服务，只要这些软件或服务已经通过 systemd 配置为服务单位（unit）。没有注册可以通过手动注册来实现控制\nln命令创建软连接 **软连接：**将文件或文件夹链接到其他位置，==类似于windows的快捷方式==\n1 ln -s 参数1 参数2 参数1：要链接的文件或文件夹 参数1：要链接去的地方 日期和时区 date命令查看时间 好的！按照类似的格式，date 命令的说明如下：\ndate 命令用法 date 命令用于显示和设置系统的日期和时间。\n1 date [-d] [+格式化字符串] -d：显示指定日期的时间，可以用于计算日期（如计算未来或过去的日期）。 ntp命令进行时间同步和校准 安装ntpyum -y install ntp 设置开机自启动systemctl enable ntpd 手动校准，需要root权限ntpdate -u ntp.aliyun.com ip地址和主机名 查询ip 1 ifconfig 主机名 查看主机名 1 hostname 修改主机名\n1 hostnamectl set-hostname 新主机名 域名解析 先查看本机记录。/etc/hosts 在联网去DNS服务器 虚拟机配置固定ip 虚拟机中配置ip地址的网关和网段（ip地址的范围）\n![](屏幕截图 2025-01-24 165409.png)\n![](屏幕截图 2025-01-24 165812.png)\n![](屏幕截图 2025-01-24 165945.png)\n手动修改配置文件，固定ip\n网卡配置文件/etc/sysconfig/network-scripts/ifcfg-ens33\n使用vim对其进行编辑\n修改第四行\ndhcp是自动获取ip，将dhcp换为static\n新增四行内容\n网络传输 ping检查指定的网络服务器是否为可联通状态 1 ping [-c num] ip或主机名 -c num：检查的次数，不写则无限次数持续检查 wget非交互式文件下载器 1 wget [-b] url -b:后台下载，将日志写到工作目录下的wget-log文件下 url：下载链接 curl命令用于发送http网络请求 用于下载文件、获取信息\n1 curl [-O] url -O：用于下载文件，当url是下载链接时保存文件 url：要发起请求的网络地址 端口 通过端口可以锁定计算机的具体程序\nLinux 系统中，端口是标识网络服务的通信通道，共有 65535 个端口号可供使用\n0 - 1023：知名端口（Well-known Ports），由 IANA（Internet Assigned Numbers Authority）分配，用于重要的服务和应用，例如 HTTP（80）、HTTPS（443）、SSH（22）、FTP（21）等。\n1024 - 49151：注册端口（Registered Ports），这些端口号是为某些应用程序、服务和进程保留的，但不如知名端口那样严格，通常由开发者或组织申请使用。通常可以随意使用\n49152 - 65535：动态端口（Dynamic or Private Ports），这些端口通常用于客户端的临时端口，如在建立连接时操作系统会自动分配这些端口。\nnmap命令查看端口占用 先下载nmap\n查看占用情况\n1 nmap 要查看的ip地址 netstat命令查看指定端口的占用情况 需要先下载\n1 yum -y install net-tools 使用\n1 netstat -anp | grep 端口号 格式正确的情况下没返回说明端口没有被使用：指定的端口号当前没有进程在监听。\n进程管理 为管理运行的程序，每个运行的程序都会被操作系统注册为系统中的一个进程。并为每个进程分配一个独有的进程id。\nps命令查看进程信息 1 ps [-e -f] -e：展示全部进程 -f：以完全格式化的形式展示信息（展示全部信息） 一般合起来用ps -ef 可以通过管道符|和grep来进行过滤，例如查找tail命令ps -ef | grep tail\nkill关闭进程 1 kill [-9] 进程id -9：强制关闭 监控主机状态 top查看资源占用 类似与windows任务管理器，默认每隔5秒刷新一次\n1 top ![](屏幕截图 2025-01-25 141245.png)\n基本选项\n-d \u0026lt;时间间隔\u0026gt;：设置刷新间隔（单位为秒）。默认值通常为 3 秒，例如 top -d 2 表示每 2 秒刷新一次。 -n \u0026lt;次数\u0026gt;：指定刷新次数后退出。例如，top -n 5 表示刷新 5 次后退出。 -b：以批处理模式运行，输出结果适合重定向到文件。例如，top -b -n 1 \u0026gt; output.txt 将当前信息保存到 output.txt。 -p \u0026lt;PID\u0026gt;：仅显示指定 PID 的进程信息。例如，top -p 1234 只监控进程号为 1234 的进程。 -u \u0026lt;用户名\u0026gt;：仅显示指定用户的进程。例如，top -u root。 -U \u0026lt;用户ID\u0026gt;：与 -u 类似，但通过用户 ID 过滤。 -H：显示线程级别的信息。 -o \u0026lt;字段\u0026gt;：按指定字段排序。例如，top -o %CPU 按 CPU 使用率排序。 运行时交互键\n当运行 top 后，可以通过以下键盘操作动态调整显示内容：\n排序相关 P：按 CPU 使用率排序（默认）。 M：按内存使用量排序。 T：按进程运行时间排序。 筛选相关 u：筛选特定用户的进程。 k：终止指定 PID 的进程。 显示相关 z：切换颜色显示。 x：高亮排序列。 c：切换显示完整命令行或仅显示进程名称。 f：调整显示字段。 h：显示帮助信息。 q：退出 top。 df命令查看硬盘的使用情况 1 df [-h] -h：单位显示 iostat命令查看cpu和磁盘信息 1 iostat [-x] [参数1] [参数2] -x：显示更多信息 参数1：数字，表示刷新间隔（秒） 参数2：数字，表示刷新几次，不写则一直刷新 sar查看网络的相关统计 由于十分复杂\n常用的写法\n1 sar -n DEV num1 num2 -n：查看网络 DEV：查看网络接口 num1：数字，表示刷新间隔（秒） num2：数字，表示刷新几次，不写则一直刷新 环境变量 环境变量是一种在操作系统中用于存储配置信息的键值对，方便系统和应用程序获取公共参数。它们像全局变量一样，可以影响系统或程序的运行环境。\nenv命令查看当前系统的环境变量 1 env $符号 通过$用环境变量的key去获取值\n例如，\n1 echo $PATH 临时\n1 export 变量名=变量值 永久\n针对当前用户：在~/bashrc文件中 针对所有用户：在/etc/profile文件中 在配置文件里写入export 变量名=变量值 立即生效使用source 配置文件名称 上传和下载 可以鼠标推拽 通过命令 安装lrzsz rz上传，window上传过来 sz下载 压缩和解压 tar和gzip更为常用\n.tar\n定义： .tar 是一种打包格式，用于将多个文件和目录合并成一个文件，方便归档和传输。 特点 仅打包文件和目录，不会压缩数据。 文件大小保持不变。 通常用于备份和归档。 .gz\n定义： .gz 是一种压缩格式，基于 Gzip（GNU zip）压缩算法，用于减少文件大小。 特点 只能压缩单个文件。 不具备打包功能。 常用于网络传输或磁盘存储优化。 .tar.gz\n定义： .tar.gz 是 .tar 和 .gz 的组合，先将文件和目录打包成 .tar 文件，再对 .tar 文件进行 Gzip 压缩。 特点 兼具打包和压缩功能。 是 Linux 系统中最常见的压缩包格式。 tar命令压缩或解压tar和gzip文件 1 tar [-z -c -x -C -v -f] 参数1 参数2 ... ... 参数n -z：不管是解压还是压缩，都使用gzip算法。不写则使用tarball算法，要使用的话一般放在第一个 -c：创建压缩文件，用于压缩模式 -x：解压模式 -C：用于解压模式，选择解压目的地 -v：查看进度。用于显示压缩、解压过程 -f：指定打包或解压的文件名（如 archive.tar）。必须放在所有选项的最后一个 常用组合 压缩 -cvf 将若干文件压缩到某个.tar文件\n例如，将1.txt和2.txt压缩到test.tar中\n1 tar -cvf test.tar 1.txt 2.txt 该命令会将当前目录下的 1.txt 和 2.txt 文件打包到一个名为 test.tar 的归档文件中。\n打包完成后，1.txt 和 2.txt 原文件依然保留，它们的副本被存储在 test.tar 中。\n-zcvf\n先将 1.txt 和 2.txt 文件打包为一个 test.tar 文件，然后用 gzip 压缩生成最终的 test.tar.gz 文件。\n1 tar -zcvf test.tar 1.txt 2.txt 解压 -xvf 解压到当前目录。\n1 tar -xvf test.tar -xvf 解压到指定目录。\n1 tar -xvf test.tar -C /home/jieya -zxvf 解压到指定目录。\n1 tar -zxvf test.tar.gz -C /home/jieya zip、unzip命令压缩或解压zip文件 zip命令压缩文件 1 zip [-r] 参数1 参数2 ... ... 参数n -r：压缩内容含有文件夹要使用-r\n例如，将a.txt和b.txt压缩到test.zip里\n1 zip -r test.zip a.txt b.txt unzip解压 1 unzip [-d] zip压缩包文件 -d：同上面tar命令的-C类似，指定解压目录\n解压到当前目录\n例如，unzip test.zip\n解压到指定目录\n例如，unzip test.zip -d /home/jieya\n目录不存在，unzip 会报错，提示目标目录不存在。有同名文件会覆盖\n","date":"2025-01-15T00:00:00Z","permalink":"https://suechinrry.github.io/p/linux/","title":"Linux"},{"content":"Redis简介 Redis 是一个基于键值对（Key-Value）的 NoSQL 数据库，属于非关系型数据库。\n官网：\n中文：https://www.redis.com.cn/documentation.html\n英文：Redis - The Real-time Data Platform\n参考命令：http://doc.redisfans.com/\n下载 redis/redis-hashes: Redis tarball SHA1 hashes\n","date":"2025-01-15T00:00:00Z","permalink":"https://suechinrry.github.io/p/redis/","title":"Redis"},{"content":"数组 数组是存放在连续内存空间上的相同类型数据的集合。\n下标从0开始 内存空间的地址是连续的 数组的元素不能删除只能覆盖 二分法 使用前提：有序数组，无重复元素\n二分法\nleft，right，middle只根据条件来改变left或right的值，middle的值自然会改变\n写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。\n两种写法的区别while循环条件不同，r的赋值不同\n写法1：[left, right]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int search(int[] nums, int target) { int l=0; int r=nums.length-1; int mid=0; while(l\u0026lt;=r){ mid= l + ((r - l) / 2); if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid-1; } else{ return mid; } } return -1; } } 将mid=（l+r）/2换成mid= l + ((r - l) / 2)的原因:当l和r都很大时，会导致溢出。\n写法2：[left,right)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int search(int[] nums, int target) { int l=0; int r=nums.length; int mid=0; while(l\u0026lt;r){ mid=l+(r-l)/2; if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid; } else{ return mid; } } return -1; } } 相关题目 35.搜索插入位置 N 暴力解法\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public int searchInsert(int[] nums, int target) { for(int i=0;i\u0026lt;nums.length;i++){ // 一旦发现大于或者等于target的num[i]，那么i就是我们要的结果 if(nums[i]\u0026gt;=target){ return i; } } return nums.length; } } 二分查找\n写法1：[l,r]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int searchInsert(int[] nums, int target) { int l=0; int r=nums.length-1; int mid=0; while(l\u0026lt;=r){ mid=l+(r-l)/2; if(target\u0026gt;nums[mid]){ l=mid+1; } else if(target\u0026lt;nums[mid]){ r=mid-1; } else{ return mid; } } //数组中未找到target元素 //target在数组所有元素之后，[left, right]是右闭区间，需要返回 right +1 return r+1; } } r 指针已经指向了数组中小于 target 的最后一个元素的位置\n34.在排序数组中查找元素的第一个和最后一个位置 含有重复元素时\n用两个二分法来查找左右边界\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int[] searchRange(int[] nums, int target) { int[] answer = new int[]{-1, -1}; int l = 0; int r = nums.length - 1; int mid = 0; int leftBorder = -1; int rightBorder = -1; // 查找左边界 while (l \u0026lt;= r) { mid = l + (r - l) / 2; if (nums[mid] \u0026gt;= target) { r = mid - 1; leftBorder = mid; // 更新左边界 } else { l = mid + 1; } } // 查找右边界 l = 0; r = nums.length - 1; while (l \u0026lt;= r) { mid = l + (r - l) / 2; if (nums[mid] \u0026lt;= target) { l = mid + 1; rightBorder = mid; // 更新右边界 } else { r = mid - 1; } } // 情况一：目标值不存在 if (leftBorder == -1 || rightBorder == -1 || nums[leftBorder] != target) { return new int[]{-1, -1}; } // 返回目标值的开始位置和结束位置 return new int[]{leftBorder, rightBorder}; } } 查找左边界的核心目标\n我们需要找到目标值在数组中最早出现的位置。在二分查找的过程中，r 和 l 指针会根据当前查找的值是否符合目标来不断调整。关键的思想是通过“收缩查找范围”来逼近目标值的左边界。\n为什么使用 r 来确定左边界？\n当 nums[mid] \u0026gt;= target 时，我们可以确定目标值可能在当前位置 mid 或 mid 左侧的区间。 为什么是左侧？ 因为我们正在寻找左边界，而且数组是非递减顺序排列的。如果当前 nums[mid] 大于或等于目标值，目标值可能出现在 mid 或它的左边。 例如，如果目标值是 8，在 [5, 7, 7, 8, 8, 10] 这样的数组中，8 出现了两次。你需要确定目标值第一个出现的位置。即便在 mid 处找到了 8，我们还需要继续查找 mid 左侧，看看是否存在更早的 8。 收缩右边界 r = mid - 1，这样我们就会继续在 mid 左边的区间进行查找。因为目标值可能出现在 mid 或它的左侧。 更新 leftBorder = r： 当 nums[mid] \u0026gt;= target 时，目标值在 mid 或它的左边，所以我们更新 r 位置为左边界的位置（r 逐步逼近目标值的左侧）。 这时，leftBorder 记录的其实是当前 mid 左侧的一个边界，而不是 mid 本身。因为如果 nums[mid] \u0026gt;= target，说明目标值应该在 mid 或左边，所以我们更新左边界为 r，以便后续判断是否存在更小的值。 leftBorder == -1\nleftBorder 用来记录目标值在数组中最左边的出现位置。如果 leftBorder 为 -1，意味着在查找左边界的过程中没有找到目标值。也就是说，目标值在数组中不存在，所以此时应该返回 [-1, -1]，表示目标值不存在。\n为什么是 -1？ 在查找过程中，leftBorder 的初始值是 -1，只有当查找到目标值时才会更新 leftBorder。如果最终没有找到目标值，leftBorder 仍然保持为 -1。 nums[leftBorder] != target\n这一部分检查在找到的 leftBorder 位置是否真的等于目标值 target。也就是说，即使 leftBorder 不等于 -1，我们还需要确认 nums[leftBorder] 这个位置的值是否确实是目标值 target。\n为什么要做这个检查？ 可能出现一种情况：假设目标值并未出现在数组中，但二分查找的过程可能仍然会更新 leftBorder 为某个位置。为了确保 leftBorder 位置的值确实是目标值，我们需要进行额外的检查。只有当 nums[leftBorder] == target 时，才说明 leftBorder 是有效的目标值出现位置。 组合解释：\n如果 leftBorder == -1，表示目标值在数组中不存在，所以直接返回 [-1, -1]。 如果 rightBorder == -1，同样表示目标值在数组中不存在，所以也返回 [-1, -1]。 如果 nums[leftBorder] != target，说明 leftBorder 虽然不是 -1，但是找到了一个错误的位置，或者在 leftBorder 位置并没有找到目标值。因此，也应该返回 [-1, -1]。 为什么是 leftBorder = mid 而不是 leftBorder = r？\n查找左边界的目标是找到 目标值第一次出现的位置。在二分查找的过程中，当 nums[mid] \u0026gt;= target 时，说明目标值可能在 mid 或它的左边，所以我们需要继续往左侧查找，并且 mid 是可能的左边界。\n如果 nums[mid] \u0026gt;= target，说明目标值可能在 mid 位置或其左边\n：\n为什么mid 是可能的左边界？ 假设数组是 [5, 7, 7, 8, 8, 10]，我们要查找目标值 8。 当我们在 mid = 3 时，发现 nums[mid] == 8，这时我们知道 8 出现在 mid 位置或者它左边的位置。 因为我们要找到 第一次出现的位置，即最左边的目标值，所以即使在 mid 处找到了目标值，我们仍然需要继续向左查找。 69.x 的平方根 N 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int mySqrt(int x) { if (x == 0) return 0; int l=1; int r=x; int mid=0; while(l\u0026lt;=r){ mid=l+(r-l)/2; if(x/mid\u0026lt;mid){ r=mid-1; } else if(x/mid\u0026gt;mid){ l=mid+1; } else{ return mid; } } return r; } } 为了防止溢出，将mid*mid\u0026gt;x换位x/mid\u0026lt;mid 二分查找最终会使得 l \u0026gt; r，此时区间 [l, r] 会被缩小到一个无法继续分割的状态。此时，r 就是比 sqrt(x) 小的最大整数。 367.有效的完全平方数 移除元素 移除元素 N\n暴力解法，两层for循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int removeElement(int[] nums, int val) { int n=nums.length; for(int i=0;i\u0026lt;n;i++){ if(nums[i]==val){ for(int j=i+1;j\u0026lt;n;j++){ nums[j-1]=nums[j]; } n--;//长度减一 i--;//下一次还是得从现在这个位置开始。 } } return n; } } 双指针\nfast遍历整个数组，slow用来指向更新新数组下标的位置。\n其实count没必要\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int removeElement(int[] nums, int val) { int slow=0; int count=0; for(int fast=0;fast\u0026lt;nums.length;fast++){ if(nums[fast]!=val){//不是目标数就进行更新，将下标为fast的值更新到下标slow nums[slow]=nums[fast]; slow++; count++; } //与目标值相等就不做处理，等待被覆盖 } return count; } } 相关题目 26.删除排序数组中的重复项 N 第一个元素不用处理，从第二个元素开始。所以slow的初始值是1，fast的初始值也为1，而且为了避免下标溢出，将nums[fast]!=nums[fast+1]换成nums[fast]!=nums[fast-1]。\nslow 指针始终指向下一个应该放置去重后元素的位置。每当我们遇到一个不重复的元素时，我们就将其放入 nums[slow] 位置，并且增加 slow 的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int slow=1; for(int fast=1;fast\u0026lt;nums.length;fast++){ if(nums[fast]!=nums[fast-1]){ nums[slow]=nums[fast]; slow++; } } return slow; } } 283.移动零 844.比较含退格的字符串 ==对于数组，直接使用 length，不加括号。==\n==对于字符串，使用 length() 方法，记得加括号。==\nStringBuilder 和 StringBuffer 可变的字符串类\n如果你只在单线程环境中操作字符串，使用 StringBuilder 更好，因为它性能更优。 如果你需要在多线程环境中操作同一个字符串对象，使用 StringBuffer，它提供了线程安全保证，但性能可能稍逊色。 以下类和接口可以用作栈：\nStack（传统栈类） Deque（推荐，使用 ArrayDeque 或 LinkedList 实现） LinkedList（兼容双端队列和栈） 自定义栈（数组或链表实现） 线程安全的栈（如 Collections.synchronizedDeque 包装的 Deque） 优先推荐使用 Deque 接口（如 ==ArrayDeque==），因为它性能更高且设计更现代化。\n栈相关方法：\nArrayDeque 实现了 Deque 接口，支持以下与栈相关的方法：\npush(E e)\n将元素压入栈（队列的头部）。 等同于 addFirst()。 时间复杂度：O(1)。 1 2 3 ArrayDeque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push(1); // 入栈 stack.push(2); // 入栈 pop()\n移除并返回栈顶元素（队列的头部元素）。 等同于 removeFirst()。 如果栈为空，调用此方法会抛出 NoSuchElementException。 时间复杂度：O(1)。 1 int element = stack.pop(); // 出栈，输出 2 peek()\n返回栈顶元素，但不移除它（查看队列的头部元素）。 等同于 peekFirst()。 如果栈为空，返回 null。 时间复杂度：O(1)。 1 int top = stack.peek(); // 查看栈顶元素，输出 1 isEmpty()\n判断栈是否为空。 时间复杂度：O(1)。 1 boolean isEmpty = stack.isEmpty(); // 判断栈是否为空 size()\n返回栈的元素个数。 时间复杂度：O(1)。 1 int size = stack.size(); // 返回栈的大小 977.有序数组的平方 N 暴力\n1 2 3 4 5 6 7 8 9 class Solution { public int[] sortedSquares(int[] nums) { for(int i=0;i\u0026lt;nums.length;i++){ nums[i]=nums[i]*nums[i]; } Arrays.sort(nums); return nums; } } 双指针排序\n左边从0开始，右边从length-1开始。\n因为数组是按照非递减排列的，所以说右边的数大于等于左边。\n==这道题求的是平方大的。==\nnums[left]与nusm[right]相加。大于0，则说明right下标的数要大些；小于0，就说明left下标的绝对值要大些\n==这个比较相加大于0小于0代替比较两个数的平方的大小。==\n比较完后，将得到的结构写道新的数组里，而且还要移动左或者右指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int[] sortedSquares(int[] nums) { int left=0; int right=nums.length-1; int[] answer=new int[nums.length]; int i=nums.length-1; while(left\u0026lt;=right){ if(nums[left]+nums[right]\u0026lt;0){ answer[i]=nums[left]*nums[left]; left++; } else{ answer[i]=nums[right]*nums[right]; right--; } i--; } return answer; } } 若仅仅按照大小排列则为以下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int[] sortedArray(int[] nums) { int left = 0; // 左指针 int right = nums.length - 1; // 右指针 int[] answer = new int[nums.length]; // 用于存储结果 int i = 0; // 从结果数组的开头开始填充 while (left \u0026lt;= right) { if (nums[left] \u0026lt;= nums[right]) { answer[i] = nums[left]; left++; } else { answer[i] = nums[right]; right--; } i++; } return answer; } } 长度最小的子数组 长度最小的子数组 这道题的子数组数连续的\n暴力\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int minSubArrayLen(int target, int[] nums) { int sum=0; int min=Integer.MAX_VALUE; for(int i=0;i\u0026lt;nums.length;i++){ sum=0; for(int j=i;j\u0026lt;nums.length;j++){ sum+=nums[j]; if(sum\u0026gt;=target){ min=Math.min(min,j-i+1); break; } } } return min==Integer.MAX_VALUE?0:min; } } 滑动窗口（双指针）\n只用一个for循环，这个循环是确定终止位置的\nfor循环里，for(int end=0; end\u0026lt;nums.length; end++)；扩大窗口，每次通过 sum+=nums[end] 增加当前窗口的和。\n如果加上后大于target，则开始移动start。（开始移动是指移动到sum不满足大于target为止，所以需要用while而不是if，并且每次移动后都要记录最小子数组的长度）\n为什么start不需要再每次for循环时重置为0？\n因为，sum满足大于target这个条件时（ while(sum\u0026gt;=target)）,会尝试减小，减小值为当前nums[start]，sum的和就不会再包含当前start下标的值了。如果每次循环都重置为0，就会删除sum本身不包含的数，会导致错误。\n下面是gpt的回答：\n为什么 start 不需要在每次 for 循环时重置为 0？\n滑动窗口的动态调整机制 在滑动窗口算法中，start 的作用是 调整窗口的左边界，使得当前窗口的和 (sum) 满足问题的要求（比如大于等于 target）。 一旦 sum \u0026gt;= target，我们通过移动 start（即增加 start 的值），缩小窗口的左边界，同时从 sum 中减去 nums[start] 的值。这种操作是基于当前窗口的状态进行的，不需要从头（start = 0）重新开始调整。 如果每次外层循环都重置 start = 0，就会丢失滑动窗口算法的核心逻辑，即在前一次窗口调整的基础上继续调整，这会导致重复计算和逻辑错误。 为什么不能删除不属于当前窗口的值？ 如果 start 被重置为 0，我们就会尝试减去 nums[start]（比如 nums[0]），但这些值可能已经被移出了当前窗口（while(sum \u0026gt;= target) 的过程中已经移除了）。此时的 sum 已经不再包含这些值，减去它们会导致错误的计算。 动态收缩窗口 vs 重置窗口 动态收缩窗口：每次 sum \u0026gt;= target 时，只通过增加 start 的方式调整窗口，确保窗口和始终基于当前窗口的实际范围。 重置窗口：如果每次外层循环都将 start 重置为 0，就会导致每次都从头开始重新计算窗口。这种做法会让算法丢失滑动窗口的高效性，同时也会引入逻辑错误（因为 sum 不包含窗口外的值）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int minSubArrayLen(int target, int[] nums) { int start=0; int sum=0; int min=Integer.MAX_VALUE; for(int end=0;end\u0026lt;nums.length;end++){ sum+=nums[end]; while(sum\u0026gt;=target){ sum-=nums[start]; min=Math.min(min,end-start+1); start++; } } return min==Integer.MAX_VALUE?0:min; } } 相关题目 904.水果成篮 N 先减少水果数量，再检查是否移除水果键。不然会移除一个不存在的键而报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int totalFruit(int[] fruits) { int left=0; int max=Integer.MIN_VALUE; Map\u0026lt;Integer,Integer\u0026gt; fruitsMap=new HashMap\u0026lt;\u0026gt;(); for(int right=0;right\u0026lt;fruits.length;right++){ fruitsMap.put(fruits[right],fruitsMap.getOrDefault(fruits[right],0)+1); while(fruitsMap.size()\u0026gt;2){ fruitsMap.put(fruits[left],fruitsMap.get(fruits[left])-1); if(fruitsMap.get(fruits[left])==0){ fruitsMap.remove(fruits[left]); } left++; } max=Math.max(max,right-left+1); } return max; } } 76.最小覆盖子串 ","date":"2025-01-13T22:27:13+08:00","image":"https://suechinrry.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/lst_hu_1525ede3a30447c3.jpg","permalink":"https://suechinrry.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","title":"数据结构与算法"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","permalink":"https://suechinrry.github.io/p/placeholder-text/","title":"Placeholder Text"}]